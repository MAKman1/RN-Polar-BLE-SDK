// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: types.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers.h>
#else
 #import "google/GPBProtocolBuffers.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30002
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30002 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

CF_EXTERN_C_BEGIN

@class PbCalibrationSettings;
@class PbDate;
@class PbDuration;
@class PbSystemDateTime;
@class PbTime;

NS_ASSUME_NONNULL_BEGIN

#pragma mark - Enum PbDataType

typedef GPB_ENUM(PbDataType) {
  /** Not defined */
  PbDataType_Undefined = 0,

  /** Inherited from parent field (for generics) */
  PbDataType_Inherited = 1,

  /** Reserved for enumerations */
  PbDataType_Enum = 2,

  /** Milliseconds */
  PbDataType_Millis = 3,

  /** Seconds */
  PbDataType_Second = 4,

  /** Minutes */
  PbDataType_Minute = 5,

  /** Hours */
  PbDataType_Hour = 6,

  /** Hours */
  PbDataType_Hours = 7,

  /** Day of month */
  PbDataType_Day = 8,

  /** Month */
  PbDataType_Month = 9,

  /** Year */
  PbDataType_Year = 10,

  /** Kilograms */
  PbDataType_Weight = 11,

  /** Centimeters */
  PbDataType_Height = 12,

  /** ml/kg/min */
  PbDataType_Vo2Max = 13,

  /** bpm */
  PbDataType_Heartrate = 20,

  /** hr% */
  PbDataType_HrPercent = 21,

  /** hrr */
  PbDataType_HrReserve = 22,

  /** km/h */
  PbDataType_Speed = 23,

  /** Rotations per minute (rpm) */
  PbDataType_Cadence = 24,

  /** Meters */
  PbDataType_Altitude = 25,

  /** Watts */
  PbDataType_Power = 26,

  /** Percentage of left foot */
  PbDataType_PowerLrb = 27,

  /** 0-100 ("Percentage") */
  PbDataType_PowerPi = 28,

  /** Celsius */
  PbDataType_Temperature = 29,

  /** Metabolic Equivalent of Task (MET) */
  PbDataType_Activity = 30,

  /** Stride length while running (cm) */
  PbDataType_StrideLength = 31,

  /** Climbing angle (%) */
  PbDataType_Incline = 32,

  /** Descending angle (%) */
  PbDataType_Decline = 33,

  /** Meters */
  PbDataType_Distance = 52,

  /** Energy consumption (kcal), float. */
  PbDataType_Energy = 53,

  /** Percentage */
  PbDataType_FatPercents = 54,

  /** Continuous ascent */
  PbDataType_Ascent = 55,

  /** Continuous descent */
  PbDataType_Descent = 56,

  /** Latitude */
  PbDataType_Latitude = 57,

  /** Longitude */
  PbDataType_Longitude = 58,

  /** Hertz */
  PbDataType_Hertz = 59,

  /** 0-100 Percentage */
  PbDataType_Percent = 60,

  /** Amount of activity cumulated during single day (METmin) */
  PbDataType_CumulatedActivityDay = 61,

  /** Running index result */
  PbDataType_RunningIndex = 62,

  /** ms */
  PbDataType_RrInterval = 63,

  /** Orthostatic test: Z-index */
  PbDataType_ZIndex = 64,

  /** Exercise target index */
  PbDataType_ExerciseTargetIndex = 65,

  /** Time zone offset in minutes */
  PbDataType_TimeZoneOffset = 66,

  /** Bike wheel size */
  PbDataType_WheelSize = 67,

  /** Fitness class [1 - 7] based on VO2max, age and gender */
  PbDataType_FitnessClass = 68,

  /** User 1d acceleration (m/s2) */
  PbDataType_Acceleration = 69,

  /** Length of the crank in bike */
  PbDataType_CrankLength = 70,

  /** General positive angle in degrees */
  PbDataType_AngleDegree = 71,

  /** Force values (N) */
  PbDataType_Newton = 72,

  /** FTP value in watts */
  PbDataType_FunctionalThresholdPower = 73,

  /** Energy consumption (kcal), integer. */
  PbDataType_Calories = 74,

  /** Calibration offset calculated from two speed sources (km/h) */
  PbDataType_SpeedCalibrationOffset = 75,

  /** Week number */
  PbDataType_Week = 76,

  /** Load of cardio activity (exercise or activity), float */
  PbDataType_CardioLoad = 77,

  /** MAP value in watts */
  PbDataType_MaximumAerobicPower = 78,

  /** MAS value in km/h */
  PbDataType_MaximumAerobicSpeed = 79,

  /** Muscle load of an exercise. Related to power measurement (J) */
  PbDataType_MuscleLoad = 80,

  /** Perceived load of an exercise, float */
  PbDataType_PerceivedLoad = 81,
};

GPBEnumDescriptor *PbDataType_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PbDataType_IsValidValue(int32_t value);

#pragma mark - Enum PbHeartRateView

typedef GPB_ENUM(PbHeartRateView) {
  PbHeartRateView_HeartRateViewBpm = 1,
  PbHeartRateView_HeartRateViewPercentsOfHrReserve = 2,
  PbHeartRateView_HeartRateViewPercentsOfMaxHr = 3,
};

GPBEnumDescriptor *PbHeartRateView_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PbHeartRateView_IsValidValue(int32_t value);

#pragma mark - Enum PbUnitSystem

typedef GPB_ENUM(PbUnitSystem) {
  PbUnitSystem_Metric = 1,
  PbUnitSystem_Imperial = 2,
};

GPBEnumDescriptor *PbUnitSystem_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PbUnitSystem_IsValidValue(int32_t value);

#pragma mark - Enum PbTimeSelection

typedef GPB_ENUM(PbTimeSelection) {
  PbTimeSelection_Time1 = 1,
  PbTimeSelection_Time2 = 2,
};

GPBEnumDescriptor *PbTimeSelection_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PbTimeSelection_IsValidValue(int32_t value);

#pragma mark - Enum PbTimeFormat

typedef GPB_ENUM(PbTimeFormat) {
  PbTimeFormat_TimeFormat24H = 1,
  PbTimeFormat_TimeFormat12H = 2,
};

GPBEnumDescriptor *PbTimeFormat_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PbTimeFormat_IsValidValue(int32_t value);

#pragma mark - Enum PbTimeFormatSeparator

typedef GPB_ENUM(PbTimeFormatSeparator) {
  PbTimeFormatSeparator_TimeFormatSeparatorDot = 1,
  PbTimeFormatSeparator_TimeFormatSeparatorColon = 2,
};

GPBEnumDescriptor *PbTimeFormatSeparator_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PbTimeFormatSeparator_IsValidValue(int32_t value);

#pragma mark - Enum PbStartDayOfWeek

typedef GPB_ENUM(PbStartDayOfWeek) {
  PbStartDayOfWeek_Monday = 1,
  PbStartDayOfWeek_Saturday = 2,
  PbStartDayOfWeek_Sunday = 3,
};

GPBEnumDescriptor *PbStartDayOfWeek_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PbStartDayOfWeek_IsValidValue(int32_t value);

#pragma mark - Enum PbDateFormatSeparator

typedef GPB_ENUM(PbDateFormatSeparator) {
  PbDateFormatSeparator_Dot = 1,
  PbDateFormatSeparator_Slash = 2,
  PbDateFormatSeparator_Hyphen = 3,
};

GPBEnumDescriptor *PbDateFormatSeparator_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PbDateFormatSeparator_IsValidValue(int32_t value);

#pragma mark - Enum PbDateFormat

typedef GPB_ENUM(PbDateFormat) {
  PbDateFormat_DdMmYyyy = 1,
  PbDateFormat_MmDdYyyy = 2,
  PbDateFormat_YyyyMmDd = 3,
};

GPBEnumDescriptor *PbDateFormat_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PbDateFormat_IsValidValue(int32_t value);

#pragma mark - Enum PbFeatureType

/**
 * types of data that are suitable for bluetooth device features
 * NOTE: DO NOT CHANGE THE NUMBERS, instead add new ones at the end
 * of the enum
 **/
typedef GPB_ENUM(PbFeatureType) {
  PbFeatureType_FeatureTypeHeartRate = 1,
  PbFeatureType_FeatureTypeRrInterval = 2,
  PbFeatureType_FeatureTypeSpeed = 3,
  PbFeatureType_FeatureTypeDistance = 4,
  PbFeatureType_FeatureTypeBikeCadence = 5,
  PbFeatureType_FeatureTypeBikePower = 6,
  PbFeatureType_FeatureTypeGpsLocation = 7,
  PbFeatureType_FeatureTypeRunningCadence = 8,
  PbFeatureType_FeatureTypePressTemperature = 9,
  PbFeatureType_FeatureTypeAltitude = 10,
  PbFeatureType_FeatureTypeSteps = 11,
  PbFeatureType_FeatureTypeActivity = 12,
  PbFeatureType_FeatureTypeStrideLength = 13,
  PbFeatureType_FeatureTypeRscMovingType = 14,
  PbFeatureType_FeatureTypeJumpHeigth = 15,
  PbFeatureType_FeatureTypeCompassHeading = 16,
  PbFeatureType_FeatureTypeGpsSpeed = 17,
  PbFeatureType_FeatureTypeGpsDistance = 18,
  PbFeatureType_FeatureTypeGpsAltitude = 19,
  PbFeatureType_FeatureTypeBikeWheelRevolution = 20,
  PbFeatureType_FeatureTypeBikeCrankRevolution = 21,
  PbFeatureType_FeatureTypeAsSpeed = 22,
  PbFeatureType_FeatureTypeAsCadence = 23,
  PbFeatureType_FeatureTypeAsDistance = 24,
  PbFeatureType_FeatureTypeAsSwrState = 25,
  PbFeatureType_FeatureTypeBatteryLevel = 26,
  PbFeatureType_FeatureTypeFileTransfer = 27,
  PbFeatureType_FeatureTypePushNotifications = 28,
  PbFeatureType_FeatureTypeWeightScale = 29,
  PbFeatureType_FeatureTypeRemoteButtons = 30,
  PbFeatureType_FeatureTypeGopro = 31,
  PbFeatureType_FeatureTypePpInterval = 32,
};

GPBEnumDescriptor *PbFeatureType_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PbFeatureType_IsValidValue(int32_t value);

#pragma mark - Enum PbMovingType

typedef GPB_ENUM(PbMovingType) {
  PbMovingType_Walking = 0,
  PbMovingType_Running = 1,
  PbMovingType_Standing = 2,
};

GPBEnumDescriptor *PbMovingType_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PbMovingType_IsValidValue(int32_t value);

#pragma mark - Enum PbOperationType

typedef GPB_ENUM(PbOperationType) {
  PbOperationType_Multiply = 1,
  PbOperationType_Sum = 2,
};

GPBEnumDescriptor *PbOperationType_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PbOperationType_IsValidValue(int32_t value);

#pragma mark - Enum PbExerciseFeedback

typedef GPB_ENUM(PbExerciseFeedback) {
  PbExerciseFeedback_FeedbackNone = 1,
  PbExerciseFeedback_Feedback1 = 2,
  PbExerciseFeedback_Feedback2 = 3,
  PbExerciseFeedback_Feedback3 = 4,
  PbExerciseFeedback_Feedback4 = 5,
  PbExerciseFeedback_Feedback5 = 6,
  PbExerciseFeedback_Feedback6 = 7,
  PbExerciseFeedback_Feedback7 = 8,
  PbExerciseFeedback_Feedback8 = 9,
  PbExerciseFeedback_Feedback9 = 10,
  PbExerciseFeedback_Feedback10 = 11,
  PbExerciseFeedback_Feedback11 = 12,
  PbExerciseFeedback_Feedback12 = 13,
  PbExerciseFeedback_Feedback13 = 14,
  PbExerciseFeedback_Feedback14 = 15,
  PbExerciseFeedback_Feedback15 = 16,
  PbExerciseFeedback_Feedback16 = 17,
  PbExerciseFeedback_Feedback17 = 18,
};

GPBEnumDescriptor *PbExerciseFeedback_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PbExerciseFeedback_IsValidValue(int32_t value);

#pragma mark - Enum PbHeartRateZoneSettingSource

typedef GPB_ENUM(PbHeartRateZoneSettingSource) {
  /** HRmax based */
  PbHeartRateZoneSettingSource_HeartRateZoneSettingSourceDefault = 0,

  /** An/aerobic threshold based */
  PbHeartRateZoneSettingSource_HeartRateZoneSettingSourceThreshold = 1,

  /** User's freely selected */
  PbHeartRateZoneSettingSource_HeartRateZoneSettingSourceFree = 2,
};

GPBEnumDescriptor *PbHeartRateZoneSettingSource_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PbHeartRateZoneSettingSource_IsValidValue(int32_t value);

#pragma mark - Enum PbPowerZoneSettingSource

typedef GPB_ENUM(PbPowerZoneSettingSource) {
  /** FTP based */
  PbPowerZoneSettingSource_PowerZoneSettingSourceDefault = 0,

  /** User's freely selected */
  PbPowerZoneSettingSource_PowerZoneSettingSourceFree = 1,
};

GPBEnumDescriptor *PbPowerZoneSettingSource_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PbPowerZoneSettingSource_IsValidValue(int32_t value);

#pragma mark - Enum PbSpeedZoneSettingSource

typedef GPB_ENUM(PbSpeedZoneSettingSource) {
  /** Sport specific, pre-defined by Polar */
  PbSpeedZoneSettingSource_SpeedZoneSettingSourceDefault = 0,

  /** User's freely selected */
  PbSpeedZoneSettingSource_SpeedZoneSettingSourceFree = 1,
};

GPBEnumDescriptor *PbSpeedZoneSettingSource_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PbSpeedZoneSettingSource_IsValidValue(int32_t value);

#pragma mark - Enum PbMacType

typedef GPB_ENUM(PbMacType) {
  PbMacType_MacTypePublic = 0,
  PbMacType_MacTypeStatic = 1,
  PbMacType_MacTypePrivateNonresolvable = 2,
  PbMacType_MacTypePrivateResolvable = 3,

  /** BT classic uses public address, but we use different type internally */
  PbMacType_MacTypeBtClassic = 4,
};

GPBEnumDescriptor *PbMacType_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PbMacType_IsValidValue(int32_t value);

#pragma mark - Enum PbSwimmingStyle

typedef GPB_ENUM(PbSwimmingStyle) {
  /** Other (not swimming) */
  PbSwimmingStyle_Other = -1,

  /** Between swimming styles */
  PbSwimmingStyle_Turn = 0,

  /** Swimming style not definable but still swimming */
  PbSwimmingStyle_OtherSwimming = 10,

  /** Freestyle */
  PbSwimmingStyle_Freestyle = 11,

  /** Breaststroke */
  PbSwimmingStyle_Breaststroke = 12,

  /** Backstroke */
  PbSwimmingStyle_Backstroke = 13,

  /** Butterfly */
  PbSwimmingStyle_Butterfly = 14,

  /** Any drill type (eg. kick board drills) */
  PbSwimmingStyle_Drill = 15,
};

GPBEnumDescriptor *PbSwimmingStyle_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PbSwimmingStyle_IsValidValue(int32_t value);

#pragma mark - Enum PbSwimmingPoolUnits

typedef GPB_ENUM(PbSwimmingPoolUnits) {
  /** Swimming has been exercised in meter sized pool */
  PbSwimmingPoolUnits_SwimmingPoolMeters = 0,

  /** Swimming has been exercise in yards sized pool */
  PbSwimmingPoolUnits_SwimmingPoolYards = 1,
};

GPBEnumDescriptor *PbSwimmingPoolUnits_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PbSwimmingPoolUnits_IsValidValue(int32_t value);

#pragma mark - Enum PbExerciseTargetType

typedef GPB_ENUM(PbExerciseTargetType) {
  PbExerciseTargetType_ExerciseTargetTypeFree = 0,
  PbExerciseTargetType_ExerciseTargetTypeVolume = 1,
  PbExerciseTargetType_ExerciseTargetTypePhased = 2,
  PbExerciseTargetType_ExerciseTargetTypeRoute = 3,
  PbExerciseTargetType_ExerciseTargetTypeSteadyRacePace = 4,
  PbExerciseTargetType_ExerciseTargetTypeRouteRacePace = 5,
  PbExerciseTargetType_ExerciseTargetTypeStravaSegment = 6,
};

GPBEnumDescriptor *PbExerciseTargetType_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PbExerciseTargetType_IsValidValue(int32_t value);

#pragma mark - Enum Buttons

/** Enums for transferring button state to/from device */
typedef GPB_ENUM(Buttons) {
  /** Guitar, Archer: up */
  Buttons_ButtonPlus = 0,

  /** Guitar, Archer: down */
  Buttons_ButtonMinus = 1,

  /** Guitar, Archer: start */
  Buttons_ButtonOk = 2,

  /** Guitar, Archer: light */
  Buttons_ButtonLight = 3,

  /** Guitar, Archer: back */
  Buttons_ButtonBack = 4,
};

GPBEnumDescriptor *Buttons_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL Buttons_IsValidValue(int32_t value);

#pragma mark - Enum ButtonState

typedef GPB_ENUM(ButtonState) {
  ButtonState_ButtonPressed = 0,
  ButtonState_ButtonReleased = 1,
};

GPBEnumDescriptor *ButtonState_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL ButtonState_IsValidValue(int32_t value);

#pragma mark - Enum PbSampleType

/**
 *
 * Sample types
 **/
typedef GPB_ENUM(PbSampleType) {
  /** Not defined */
  PbSampleType_SampleTypeUndefined = 0,

  /** Heart rate, bpm */
  PbSampleType_SampleTypeHeartRate = 1,

  /** Cadence, Rotations per minute (rpm) */
  PbSampleType_SampleTypeCadence = 2,

  /** Altitude, meters */
  PbSampleType_SampleTypeAltitude = 3,

  /** Calibration info for altitude: indicate start and stop indexes, used calibration value and operation type of calibration */
  PbSampleType_SampleTypeAltitudeCalibration = 4,

  /** Temperature, celcius */
  PbSampleType_SampleTypeTemperature = 5,

  /** Speed, km/h */
  PbSampleType_SampleTypeSpeed = 6,

  /** Distance, meters */
  PbSampleType_SampleTypeDistance = 7,

  /** Stride length while running, cm */
  PbSampleType_SampleTypeStrideLength = 8,

  /** Calibration info for stride: indicate start and stop indexes, used calibration value and operation type of calibration */
  PbSampleType_SampleTypeStrideCalibration = 9,

  /** Forward acceleration, m/s^2 */
  PbSampleType_SampleTypeForwardAcceleration = 10,

  /** Moving type, walking running, standing */
  PbSampleType_SampleTypeMovingType = 11,

  /** Power info from left pedal */
  PbSampleType_SampleTypeLeftPedalPower = 12,

  /** Power info from right pedal */
  PbSampleType_SampleTypeRightPedalPower = 13,

  /** Calibration info for left power: indicate start and stop indexes, used calibration value and operation type of calibration */
  PbSampleType_SampleTypeLeftPedalPowerCalibration = 14,

  /** Calibration info for right power: indicate start and stop indexes, used calibration value and operation type of calibration */
  PbSampleType_SampleTypeRightPedalPowerCalibration = 15,

  /** RR-interval, ms */
  PbSampleType_SampleTypeRrInterval = 16,

  /** Acceleration based Mean Amplitude Deviation (MAD), mg */
  PbSampleType_SampleTypeAccelerationMad = 17,
};

GPBEnumDescriptor *PbSampleType_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PbSampleType_IsValidValue(int32_t value);

#pragma mark - Enum PbSampleSourceType

/**
 *
 * Sample source types
 **/
typedef GPB_ENUM(PbSampleSourceType) {
  /** Not defined */
  PbSampleSourceType_SampleSourceTypeUndefined = 0,

  /** Sample has no source, i.e., sample is offline */
  PbSampleSourceType_SampleSourceTypeOffline = 1,

  /** Heart rate measurement based samples */
  PbSampleSourceType_SampleSourceTypeHeartRate = 2,

  /** BLE heart rate measurement based samples */
  PbSampleSourceType_SampleSourceTypeHeartRateBle = 3,

  /** 5 kHz heart rate measurement based samples */
  PbSampleSourceType_SampleSourceTypeHeartRate5Khz = 4,

  /** Optical heart rate measurement based samples */
  PbSampleSourceType_SampleSourceTypeHeartRateOptical = 5,

  /** GPS measurement based samples */
  PbSampleSourceType_SampleSourceTypeGps = 6,

  /** Stride measurement based samples */
  PbSampleSourceType_SampleSourceTypeStride = 7,

  /** Samples that are based on wrist metrics like inertial (accelometer etc.) measurements */
  PbSampleSourceType_SampleSourceTypeWristMetrics = 8,

  /** Samples that are based on chest metrics like inertial (accelometer etc.) measurements */
  PbSampleSourceType_SampleSourceTypeChestMetrics = 9,

  /** Bike pedal measurement based samples */
  PbSampleSourceType_SampleSourceTypeBikePedal = 10,

  /** Bike wheel measurement based samples */
  PbSampleSourceType_SampleSourceTypeBikeWheel = 11,

  /** Bike crank measurement based samples */
  PbSampleSourceType_SampleSourceTypeBikeCrank = 12,

  /** Samples that are combined from chest metrics and gps measurements */
  PbSampleSourceType_SampleSourceTypeCombinedChestMetricsAndGps = 13,

  /** Samples that are based on upper back metrics like inertial (accelometer etc.) measurements */
  PbSampleSourceType_SampleSourceTypeUpperBackMetrics = 14,

  /** Samples that are combined from upper back metrics and gps measurements */
  PbSampleSourceType_SampleSourceTypeCombinedUpperBackMetricsAndGps = 15,
};

GPBEnumDescriptor *PbSampleSourceType_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PbSampleSourceType_IsValidValue(int32_t value);

#pragma mark - Enum PbAltitudeSetting

/**
 * Altitude recording setting values.
 *  NOTE: DO NOT CHANGE THE NUMBERS, instead add new ones at the end
 *  of the enum
 **/
typedef GPB_ENUM(PbAltitudeSetting) {
  /** Off */
  PbAltitudeSetting_AltitudeOff = 0,

  /** On */
  PbAltitudeSetting_AltitudeOn = 1,
};

GPBEnumDescriptor *PbAltitudeSetting_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PbAltitudeSetting_IsValidValue(int32_t value);

#pragma mark - Enum PbGPSSetting

/**
 * GPS recording setting values.
 *  NOTE: DO NOT CHANGE THE NUMBERS, instead add new ones at the end
 *  of the enum
 **/
typedef GPB_ENUM(PbGPSSetting) {
  /** Off */
  PbGPSSetting_GpsOff = 0,

  /** On, normal, 1 sec rec rate */
  PbGPSSetting_GpsOnNormal = 1,

  /** On, long, 60 sec rec rate */
  PbGPSSetting_GpsOnLong = 2,

  /** On, 10 Hz, 0.1 sec rec rate */
  PbGPSSetting_GpsOn10Hz = 3,

  /** On, medium, 30 sec rec rate */
  PbGPSSetting_GpsOnMedium = 4,
};

GPBEnumDescriptor *PbGPSSetting_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PbGPSSetting_IsValidValue(int32_t value);

#pragma mark - Enum PbHeartTouch

typedef GPB_ENUM(PbHeartTouch) {
  PbHeartTouch_HeartTouchOff = 1,
  PbHeartTouch_HeartTouchActivateBacklight = 2,
  PbHeartTouch_HeartTouchShowPreviousLap = 3,
  PbHeartTouch_HeartTouchShowTimeOfDay = 4,
};

GPBEnumDescriptor *PbHeartTouch_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PbHeartTouch_IsValidValue(int32_t value);

#pragma mark - Enum PbTapButtonAction

typedef GPB_ENUM(PbTapButtonAction) {
  PbTapButtonAction_TapButtonOff = 1,
  PbTapButtonAction_TapButtonTakeLap = 2,
  PbTapButtonAction_TapButtonChangeTrainingView = 3,
  PbTapButtonAction_TapButtonActivateBacklight = 4,
};

GPBEnumDescriptor *PbTapButtonAction_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PbTapButtonAction_IsValidValue(int32_t value);

#pragma mark - Enum PbHandedness

/** Obsolete, do not extend with new values */
typedef GPB_ENUM(PbHandedness) {
  PbHandedness_WuInLeftHand = 1,
  PbHandedness_WuInRightHand = 2,
  PbHandedness_WuInNecklace = 3,
};

GPBEnumDescriptor *PbHandedness_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PbHandedness_IsValidValue(int32_t value);

#pragma mark - Enum PbDeviceLocation

typedef GPB_ENUM(PbDeviceLocation) {
  PbDeviceLocation_DeviceLocationUndefined = 0,
  PbDeviceLocation_DeviceLocationOther = 1,
  PbDeviceLocation_DeviceLocationWristLeft = 2,
  PbDeviceLocation_DeviceLocationWristRight = 3,
  PbDeviceLocation_DeviceLocationNecklace = 4,
  PbDeviceLocation_DeviceLocationChest = 5,
  PbDeviceLocation_DeviceLocationUpperBack = 6,
  PbDeviceLocation_DeviceLocationFootLeft = 7,
  PbDeviceLocation_DeviceLocationFootRight = 8,
  PbDeviceLocation_DeviceLocationLowerArmLeft = 9,
  PbDeviceLocation_DeviceLocationLowerArmRight = 10,
  PbDeviceLocation_DeviceLocationUpperArmLeft = 11,
  PbDeviceLocation_DeviceLocationUpperArmRight = 12,
  PbDeviceLocation_DeviceLocationBikeMount = 13,
};

GPBEnumDescriptor *PbDeviceLocation_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PbDeviceLocation_IsValidValue(int32_t value);

#pragma mark - Enum PbSessionRPE

/**
 *
 * Session RPE (Rating Perceived Exertion) on a scale 1-10 (adopted Borg's scale).
 * Describes how demanding the whole exercise was. Only one rating for multisport.
 **/
typedef GPB_ENUM(PbSessionRPE) {
  PbSessionRPE_RpeNone = 1,
  PbSessionRPE_RpeEasy = 2,
  PbSessionRPE_RpeLight = 3,
  PbSessionRPE_RpeFairlyBrisk = 4,
  PbSessionRPE_RpeBrisk = 5,
  PbSessionRPE_RpeModerate = 6,
  PbSessionRPE_RpeFairlyHard = 7,
  PbSessionRPE_RpeHard = 8,
  PbSessionRPE_RpeExhausting = 9,
  PbSessionRPE_RpeExtreme = 10,
};

GPBEnumDescriptor *PbSessionRPE_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PbSessionRPE_IsValidValue(int32_t value);

#pragma mark - Enum PbMuscleSoreness

typedef GPB_ENUM(PbMuscleSoreness) {
  PbMuscleSoreness_MsUndefined = -1,
  PbMuscleSoreness_MsNone = 0,
  PbMuscleSoreness_MsSome = 1,
  PbMuscleSoreness_MsMuch = 2,
};

GPBEnumDescriptor *PbMuscleSoreness_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PbMuscleSoreness_IsValidValue(int32_t value);

#pragma mark - Enum PbOverallFatigue

typedef GPB_ENUM(PbOverallFatigue) {
  PbOverallFatigue_OfUndefined = -1,
  PbOverallFatigue_OfNormal = 0,
  PbOverallFatigue_OfALittle = 1,
  PbOverallFatigue_OfMuch = 2,
};

GPBEnumDescriptor *PbOverallFatigue_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PbOverallFatigue_IsValidValue(int32_t value);

#pragma mark - Enum PbSleepUserRating

typedef GPB_ENUM(PbSleepUserRating) {
  PbSleepUserRating_PbSleptUndefined = -1,
  PbSleepUserRating_PbSleptPoorly = 0,
  PbSleepUserRating_PbSleptSomewhatPoorly = 1,
  PbSleepUserRating_PbSleptNeitherPoorlyNorWell = 2,
  PbSleepUserRating_PbSleptSomewhatWell = 3,
  PbSleepUserRating_PbSleptWell = 4,
};

GPBEnumDescriptor *PbSleepUserRating_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PbSleepUserRating_IsValidValue(int32_t value);

#pragma mark - Enum PbLocation_Fix

typedef GPB_ENUM(PbLocation_Fix) {
  PbLocation_Fix_FixNone = 0,
  PbLocation_Fix_Fix2D = 1,
  PbLocation_Fix_Fix3D = 2,
};

GPBEnumDescriptor *PbLocation_Fix_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PbLocation_Fix_IsValidValue(int32_t value);

#pragma mark - Enum PbStrideSensorCalibSettings_PbStrideCalibType

typedef GPB_ENUM(PbStrideSensorCalibSettings_PbStrideCalibType) {
  PbStrideSensorCalibSettings_PbStrideCalibType_StrideCalibManual = 0,
  PbStrideSensorCalibSettings_PbStrideCalibType_StrideCalibAuto = 1,
};

GPBEnumDescriptor *PbStrideSensorCalibSettings_PbStrideCalibType_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PbStrideSensorCalibSettings_PbStrideCalibType_IsValidValue(int32_t value);

#pragma mark - Enum PbStrideSensorCalibSettings_PbRunningFactorSource

typedef GPB_ENUM(PbStrideSensorCalibSettings_PbRunningFactorSource) {
  /** Default value */
  PbStrideSensorCalibSettings_PbRunningFactorSource_RunningFactorSourceDefault = 0,

  /** Auto calibration */
  PbStrideSensorCalibSettings_PbRunningFactorSource_RunningFactorSourceAutoCalibration = 1,

  /** Manual calibration */
  PbStrideSensorCalibSettings_PbRunningFactorSource_RunningFactorSourceManualCalibration = 2,
};

GPBEnumDescriptor *PbStrideSensorCalibSettings_PbRunningFactorSource_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PbStrideSensorCalibSettings_PbRunningFactorSource_IsValidValue(int32_t value);

#pragma mark - Enum PbAutoPause_PbAutoPauseTrigger

/** Available trigger types */
typedef GPB_ENUM(PbAutoPause_PbAutoPauseTrigger) {
  PbAutoPause_PbAutoPauseTrigger_AutoPauseOff = 0,
  PbAutoPause_PbAutoPauseTrigger_AutoPauseTriggerSpeed = 1,
};

GPBEnumDescriptor *PbAutoPause_PbAutoPauseTrigger_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PbAutoPause_PbAutoPauseTrigger_IsValidValue(int32_t value);

#pragma mark - Enum PbAutoLapSettings_PbAutomaticLap

/**
 * Automatic lap setting modes.
 *  NOTE: DO NOT CHANGE THE NUMBERS, instead add new ones at the end
 *  of the enum
 **/
typedef GPB_ENUM(PbAutoLapSettings_PbAutomaticLap) {
  PbAutoLapSettings_PbAutomaticLap_AutomaticLapOff = 1,
  PbAutoLapSettings_PbAutomaticLap_AutomaticLapDistance = 2,
  PbAutoLapSettings_PbAutomaticLap_AutomaticLapDuration = 3,
  PbAutoLapSettings_PbAutomaticLap_AutomaticLapLocation = 4,
};

GPBEnumDescriptor *PbAutoLapSettings_PbAutomaticLap_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PbAutoLapSettings_PbAutomaticLap_IsValidValue(int32_t value);

#pragma mark - TypesRoot

/**
 * Exposes the extension registry for this file.
 *
 * The base class provides:
 * @code
 *   + (GPBExtensionRegistry *)extensionRegistry;
 * @endcode
 * which is a @c GPBExtensionRegistry that includes all the extensions defined by
 * this file and all files that it depends on.
 **/
@interface TypesRoot : GPBRootObject
@end

@interface TypesRoot (DynamicMethods)
/** ALL_TC */
+ (GPBExtensionDescriptor *)type;
/** ALL_TC */
+ (GPBExtensionDescriptor *)isUnion;
/** ALL_TC */
+ (GPBExtensionDescriptor *)range;
@end

#pragma mark - PbRangeOptions

typedef GPB_ENUM(PbRangeOptions_FieldNumber) {
  PbRangeOptions_FieldNumber_MinValue = 1,
  PbRangeOptions_FieldNumber_MaxValue = 2,
};

@interface PbRangeOptions : GPBMessage

/** ALL_TC */
@property(nonatomic, readwrite) int32_t minValue;

@property(nonatomic, readwrite) BOOL hasMinValue;
/** ALL_TC */
@property(nonatomic, readwrite) int32_t maxValue;

@property(nonatomic, readwrite) BOOL hasMaxValue;
@end

#pragma mark - PbDate

typedef GPB_ENUM(PbDate_FieldNumber) {
  PbDate_FieldNumber_Year = 1,
  PbDate_FieldNumber_Month = 2,
  PbDate_FieldNumber_Day = 3,
};

@interface PbDate : GPBMessage

@property(nonatomic, readwrite) uint32_t year;

@property(nonatomic, readwrite) BOOL hasYear;
@property(nonatomic, readwrite) uint32_t month;

@property(nonatomic, readwrite) BOOL hasMonth;
@property(nonatomic, readwrite) uint32_t day;

@property(nonatomic, readwrite) BOOL hasDay;
@end

#pragma mark - PbTime

typedef GPB_ENUM(PbTime_FieldNumber) {
  PbTime_FieldNumber_Hour = 1,
  PbTime_FieldNumber_Minute = 2,
  PbTime_FieldNumber_Seconds = 3,
  PbTime_FieldNumber_Millis = 4,
};

@interface PbTime : GPBMessage

@property(nonatomic, readwrite) uint32_t hour;

@property(nonatomic, readwrite) BOOL hasHour;
@property(nonatomic, readwrite) uint32_t minute;

@property(nonatomic, readwrite) BOOL hasMinute;
@property(nonatomic, readwrite) uint32_t seconds;

@property(nonatomic, readwrite) BOOL hasSeconds;
/** ALL_TC */
@property(nonatomic, readwrite) uint32_t millis;

@property(nonatomic, readwrite) BOOL hasMillis;
@end

#pragma mark - PbSystemDateTime

typedef GPB_ENUM(PbSystemDateTime_FieldNumber) {
  PbSystemDateTime_FieldNumber_Date = 1,
  PbSystemDateTime_FieldNumber_Time = 2,
  PbSystemDateTime_FieldNumber_Trusted = 3,
};

@interface PbSystemDateTime : GPBMessage

@property(nonatomic, readwrite, strong, null_resettable) PbDate *date;
/** Test to see if @c date has been set. */
@property(nonatomic, readwrite) BOOL hasDate;

@property(nonatomic, readwrite, strong, null_resettable) PbTime *time;
/** Test to see if @c time has been set. */
@property(nonatomic, readwrite) BOOL hasTime;

/**
 *
 * The flag defines if the date & time combination originated
 * from a trusted time source, such as PPT.com servers, GPS satelites,
 * GPRS network, atomic clocks etc.
 *
 * If the trusted flag is "false"
 * the date time originated from untrusted source such as "set by user manually"
 * or not set at all (some default value).
 *
 * For more information about "trusted time", please see SAGRFC27:
 * (https://swa.polar.fi/sag/wiki/SAGRFC/SAGRFC27)
 **/
@property(nonatomic, readwrite) BOOL trusted;

@property(nonatomic, readwrite) BOOL hasTrusted;
@end

#pragma mark - PbLocalDateTime

typedef GPB_ENUM(PbLocalDateTime_FieldNumber) {
  PbLocalDateTime_FieldNumber_Date = 1,
  PbLocalDateTime_FieldNumber_Time = 2,
  PbLocalDateTime_FieldNumber_ObsoleteTrusted = 3,
  PbLocalDateTime_FieldNumber_TimeZoneOffset = 4,
};

@interface PbLocalDateTime : GPBMessage

@property(nonatomic, readwrite, strong, null_resettable) PbDate *date;
/** Test to see if @c date has been set. */
@property(nonatomic, readwrite) BOOL hasDate;

@property(nonatomic, readwrite, strong, null_resettable) PbTime *time;
/** Test to see if @c time has been set. */
@property(nonatomic, readwrite) BOOL hasTime;

/** For binary compatibility with PbSystemDateTime. */
@property(nonatomic, readwrite) BOOL obsoleteTrusted;

@property(nonatomic, readwrite) BOOL hasObsoleteTrusted;
/**
 * Time zone offset
 * Range [-720 - 840] minutes
 **/
@property(nonatomic, readwrite) int32_t timeZoneOffset;

@property(nonatomic, readwrite) BOOL hasTimeZoneOffset;
@end

#pragma mark - PbDuration

typedef GPB_ENUM(PbDuration_FieldNumber) {
  PbDuration_FieldNumber_Hours = 1,
  PbDuration_FieldNumber_Minutes = 2,
  PbDuration_FieldNumber_Seconds = 3,
  PbDuration_FieldNumber_Millis = 4,
};

@interface PbDuration : GPBMessage

/** ALL_TC */
@property(nonatomic, readwrite) uint32_t hours;

@property(nonatomic, readwrite) BOOL hasHours;
/** ALL_TC */
@property(nonatomic, readwrite) uint32_t minutes;

@property(nonatomic, readwrite) BOOL hasMinutes;
/** ALL_TC */
@property(nonatomic, readwrite) uint32_t seconds;

@property(nonatomic, readwrite) BOOL hasSeconds;
/** ALL_TC */
@property(nonatomic, readwrite) uint32_t millis;

@property(nonatomic, readwrite) BOOL hasMillis;
@end

#pragma mark - PbLocation

typedef GPB_ENUM(PbLocation_FieldNumber) {
  PbLocation_FieldNumber_Latitude = 1,
  PbLocation_FieldNumber_Longitude = 2,
  PbLocation_FieldNumber_Timestamp = 3,
  PbLocation_FieldNumber_Fix = 4,
  PbLocation_FieldNumber_Satellites = 5,
};

@interface PbLocation : GPBMessage

/** ALL_TC */
@property(nonatomic, readwrite) double latitude;

@property(nonatomic, readwrite) BOOL hasLatitude;
/** ALL_TC */
@property(nonatomic, readwrite) double longitude;

@property(nonatomic, readwrite) BOOL hasLongitude;
/** ALL_TC */
@property(nonatomic, readwrite, strong, null_resettable) PbSystemDateTime *timestamp;
/** Test to see if @c timestamp has been set. */
@property(nonatomic, readwrite) BOOL hasTimestamp;

/** ALL_TC */
@property(nonatomic, readwrite) PbLocation_Fix fix;

@property(nonatomic, readwrite) BOOL hasFix;
/** ALL_TC */
@property(nonatomic, readwrite) uint32_t satellites;

@property(nonatomic, readwrite) BOOL hasSatellites;
@end

#pragma mark - PbSensorOffline

typedef GPB_ENUM(PbSensorOffline_FieldNumber) {
  PbSensorOffline_FieldNumber_StartIndex = 1,
  PbSensorOffline_FieldNumber_StopIndex = 2,
};

/**
 *
 * Provides information when a sensor has been offline.
 * ! All fields are required.
 **/
@interface PbSensorOffline : GPBMessage

/** index of first offline point */
@property(nonatomic, readwrite) uint32_t startIndex;

@property(nonatomic, readwrite) BOOL hasStartIndex;
/** index of last offline point, can have same value than start_index */
@property(nonatomic, readwrite) uint32_t stopIndex;

@property(nonatomic, readwrite) BOOL hasStopIndex;
@end

#pragma mark - PbVolume

typedef GPB_ENUM(PbVolume_FieldNumber) {
  PbVolume_FieldNumber_Volume = 1,
};

@interface PbVolume : GPBMessage

/**
 * Volume
 * Range [0 - 100] %
 **/
@property(nonatomic, readwrite) uint32_t volume;

@property(nonatomic, readwrite) BOOL hasVolume;
@end

#pragma mark - PbStrideSensorCalibSettings

typedef GPB_ENUM(PbStrideSensorCalibSettings_FieldNumber) {
  PbStrideSensorCalibSettings_FieldNumber_RunningFactor = 1,
  PbStrideSensorCalibSettings_FieldNumber_CalibType = 2,
  PbStrideSensorCalibSettings_FieldNumber_RunningFactorSource = 3,
};

@interface PbStrideSensorCalibSettings : GPBMessage

@property(nonatomic, readwrite) float runningFactor;

@property(nonatomic, readwrite) BOOL hasRunningFactor;
@property(nonatomic, readwrite) PbStrideSensorCalibSettings_PbStrideCalibType calibType;

@property(nonatomic, readwrite) BOOL hasCalibType;
/** GUITAR BUGATTI MACAN AMPERA  ACE METRO BUGATTI */
@property(nonatomic, readwrite) PbStrideSensorCalibSettings_PbRunningFactorSource runningFactorSource;

@property(nonatomic, readwrite) BOOL hasRunningFactorSource;
@end

#pragma mark - PbWeek

typedef GPB_ENUM(PbWeek_FieldNumber) {
  PbWeek_FieldNumber_WeekNumberIso8601 = 1,
  PbWeek_FieldNumber_Year = 2,
  PbWeek_FieldNumber_TimeZoneOffset = 3,
  PbWeek_FieldNumber_WeekStartDay = 4,
};

@interface PbWeek : GPBMessage

/** ISO-8601 week number */
@property(nonatomic, readwrite) uint32_t weekNumberIso8601;

@property(nonatomic, readwrite) BOOL hasWeekNumberIso8601;
/** Year */
@property(nonatomic, readwrite) uint32_t year;

@property(nonatomic, readwrite) BOOL hasYear;
/** Range [-720 - 840] minutes */
@property(nonatomic, readwrite) int32_t timeZoneOffset;

@property(nonatomic, readwrite) BOOL hasTimeZoneOffset;
/** Start day of the week at creation */
@property(nonatomic, readwrite) PbStartDayOfWeek weekStartDay;

@property(nonatomic, readwrite) BOOL hasWeekStartDay;
@end

#pragma mark - PbSampleSource

typedef GPB_ENUM(PbSampleSource_FieldNumber) {
  PbSampleSource_FieldNumber_SampleSourceType = 1,
  PbSampleSource_FieldNumber_StartIndex = 2,
  PbSampleSource_FieldNumber_StopIndex = 3,
};

/**
 *
 * Source for samples.
 * ! All fields are required.
 **/
@interface PbSampleSource : GPBMessage

/** Sample source */
@property(nonatomic, readwrite) PbSampleSourceType sampleSourceType;

@property(nonatomic, readwrite) BOOL hasSampleSourceType;
/** Index of first point for a certain sample source */
@property(nonatomic, readwrite) uint32_t startIndex;

@property(nonatomic, readwrite) BOOL hasStartIndex;
/** Index of last point for a certain sample source, can have same value than start_index */
@property(nonatomic, readwrite) uint32_t stopIndex;

@property(nonatomic, readwrite) BOOL hasStopIndex;
@end

#pragma mark - PbSensorCalibrationOffset

typedef GPB_ENUM(PbSensorCalibrationOffset_FieldNumber) {
  PbSensorCalibrationOffset_FieldNumber_SampleSourceType = 1,
  PbSensorCalibrationOffset_FieldNumber_SpeedCalOffset = 2,
};

@interface PbSensorCalibrationOffset : GPBMessage

/** Source of the data which offset is calculated, e.g. wristmetrics uses SAMPLE_SOURCE_TYPE_WRIST_METRICS */
@property(nonatomic, readwrite) PbSampleSourceType sampleSourceType;

@property(nonatomic, readwrite) BOOL hasSampleSourceType;
/** Calibration offset value */
@property(nonatomic, readwrite) float speedCalOffset;

@property(nonatomic, readwrite) BOOL hasSpeedCalOffset;
@end

#pragma mark - PbCalibrationSettings

typedef GPB_ENUM(PbCalibrationSettings_FieldNumber) {
  PbCalibrationSettings_FieldNumber_SampleType = 1,
  PbCalibrationSettings_FieldNumber_CalibrationEnabled = 2,
  PbCalibrationSettings_FieldNumber_CalibrationCalculationEnabled = 3,
};

@interface PbCalibrationSettings : GPBMessage

/** The type of the calibrate-able measurement (SAMPLE_TYPE_SPEED etc.) */
@property(nonatomic, readwrite) PbSampleType sampleType;

@property(nonatomic, readwrite) BOOL hasSampleType;
/** Calibration value use enable on/off (existing calibration value is used if true). */
@property(nonatomic, readwrite) BOOL calibrationEnabled;

@property(nonatomic, readwrite) BOOL hasCalibrationEnabled;
/** Calibration calculation enable on/off. New calibration offset value for exercise is calculated if true. */
@property(nonatomic, readwrite) BOOL calibrationCalculationEnabled;

@property(nonatomic, readwrite) BOOL hasCalibrationCalculationEnabled;
@end

#pragma mark - PbAccelerationMetrics

typedef GPB_ENUM(PbAccelerationMetrics_FieldNumber) {
  PbAccelerationMetrics_FieldNumber_SampleSourceType = 1,
  PbAccelerationMetrics_FieldNumber_CalibrationSettingsArray = 2,
};

@interface PbAccelerationMetrics : GPBMessage

/** Source of the acceleration data i.e location of the sensor (SAMPLE_SOURCE_TYPE_WRIST_METRICS etc.) */
@property(nonatomic, readwrite) PbSampleSourceType sampleSourceType;

@property(nonatomic, readwrite) BOOL hasSampleSourceType;
/** Calibration settings */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<PbCalibrationSettings*> *calibrationSettingsArray;
/** The number of items in @c calibrationSettingsArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger calibrationSettingsArray_Count;

@end

#pragma mark - PbAutoPause

typedef GPB_ENUM(PbAutoPause_FieldNumber) {
  PbAutoPause_FieldNumber_Trigger = 1,
  PbAutoPause_FieldNumber_SpeedThreshold = 2,
};

@interface PbAutoPause : GPBMessage

/** Used trigger */
@property(nonatomic, readwrite) PbAutoPause_PbAutoPauseTrigger trigger;

@property(nonatomic, readwrite) BOOL hasTrigger;
/** Speed threshold for pausing/resuming */
@property(nonatomic, readwrite) float speedThreshold;

@property(nonatomic, readwrite) BOOL hasSpeedThreshold;
@end

#pragma mark - PbAutoLapSettings

typedef GPB_ENUM(PbAutoLapSettings_FieldNumber) {
  PbAutoLapSettings_FieldNumber_AutomaticLap = 1,
  PbAutoLapSettings_FieldNumber_AutomaticLapDistance = 2,
  PbAutoLapSettings_FieldNumber_AutomaticLapDuration = 3,
};

/**
 * Autolap related settings
 **/
@interface PbAutoLapSettings : GPBMessage

/** Autolap mode */
@property(nonatomic, readwrite) PbAutoLapSettings_PbAutomaticLap automaticLap;

@property(nonatomic, readwrite) BOOL hasAutomaticLap;
/**
 * Distance based autolap trigger
 * range [100 - 99900] m
 **/
@property(nonatomic, readwrite) float automaticLapDistance;

@property(nonatomic, readwrite) BOOL hasAutomaticLapDistance;
/** Duration based autolap trigger */
@property(nonatomic, readwrite, strong, null_resettable) PbDuration *automaticLapDuration;
/** Test to see if @c automaticLapDuration has been set. */
@property(nonatomic, readwrite) BOOL hasAutomaticLapDuration;

@end

#pragma mark - PbCardioLoad

typedef GPB_ENUM(PbCardioLoad_FieldNumber) {
  PbCardioLoad_FieldNumber_ActivityLoad = 1,
  PbCardioLoad_FieldNumber_ExerciseLoad = 2,
};

@interface PbCardioLoad : GPBMessage

/** Load from activity data within the calculated time period */
@property(nonatomic, readwrite) float activityLoad;

@property(nonatomic, readwrite) BOOL hasActivityLoad;
/** Load from exercises within the calculated time period */
@property(nonatomic, readwrite) float exerciseLoad;

@property(nonatomic, readwrite) BOOL hasExerciseLoad;
@end

#pragma mark - PbPerceivedLoad

typedef GPB_ENUM(PbPerceivedLoad_FieldNumber) {
  PbPerceivedLoad_FieldNumber_SessionRpe = 1,
  PbPerceivedLoad_FieldNumber_Duration = 2,
};

/**
 *
 * Perceived load a.k.a. RPE Load a.k.a. Subjective Load: internal training load of a session.
 * Calculated by multiplying the fields below: session_rpe * duration in minutes
 * Note! session_rpe can be modified afterwards in TC, mobile or service
 **/
@interface PbPerceivedLoad : GPBMessage

/** Hardness of the exercise */
@property(nonatomic, readwrite) PbSessionRPE sessionRpe;

@property(nonatomic, readwrite) BOOL hasSessionRpe;
/** duration in seconds */
@property(nonatomic, readwrite) uint32_t duration;

@property(nonatomic, readwrite) BOOL hasDuration;
@end

NS_ASSUME_NONNULL_END

CF_EXTERN_C_END

#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
