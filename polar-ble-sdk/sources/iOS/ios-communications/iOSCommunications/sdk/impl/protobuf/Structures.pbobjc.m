// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: structures.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Structures.pbobjc.h"
 #import "Types.pbobjc.h"
 #import "Nanopb.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - StructuresRoot

@implementation StructuresRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    registry = [[GPBExtensionRegistry alloc] init];
    // Merge in the imports (direct or indirect) that defined extensions.
    [registry addExtensions:[TypesRoot extensionRegistry]];
    [registry addExtensions:[NanopbRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - StructuresRoot_FileDescriptor

static GPBFileDescriptor *StructuresRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@""
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - PbVolumeTarget

@implementation PbVolumeTarget

@dynamic hasTargetType, targetType;
@dynamic hasDuration, duration;
@dynamic hasDistance, distance;
@dynamic hasCalories, calories;

typedef struct PbVolumeTarget__storage_ {
  uint32_t _has_storage_[1];
  PbVolumeTarget_PbVolymeTargetType targetType;
  float distance;
  uint32_t calories;
  PbDuration *duration;
} PbVolumeTarget__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetType",
        .dataTypeSpecific.enumDescFunc = PbVolumeTarget_PbVolymeTargetType_EnumDescriptor,
        .number = PbVolumeTarget_FieldNumber_TargetType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbVolumeTarget__storage_, targetType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "duration",
        .dataTypeSpecific.className = GPBStringifySymbol(PbDuration),
        .number = PbVolumeTarget_FieldNumber_Duration,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbVolumeTarget__storage_, duration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "distance",
        .dataTypeSpecific.className = NULL,
        .number = PbVolumeTarget_FieldNumber_Distance,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PbVolumeTarget__storage_, distance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "calories",
        .dataTypeSpecific.className = NULL,
        .number = PbVolumeTarget_FieldNumber_Calories,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PbVolumeTarget__storage_, calories),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbVolumeTarget class]
                                     rootClass:[StructuresRoot class]
                                          file:StructuresRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbVolumeTarget__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum PbVolumeTarget_PbVolymeTargetType

GPBEnumDescriptor *PbVolumeTarget_PbVolymeTargetType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "VolumeTargetTypeDuration\000VolumeTargetTyp"
        "eDistance\000VolumeTargetTypeCalories\000";
    static const int32_t values[] = {
        PbVolumeTarget_PbVolymeTargetType_VolumeTargetTypeDuration,
        PbVolumeTarget_PbVolymeTargetType_VolumeTargetTypeDistance,
        PbVolumeTarget_PbVolymeTargetType_VolumeTargetTypeCalories,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbVolumeTarget_PbVolymeTargetType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbVolumeTarget_PbVolymeTargetType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbVolumeTarget_PbVolymeTargetType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbVolumeTarget_PbVolymeTargetType_VolumeTargetTypeDuration:
    case PbVolumeTarget_PbVolymeTargetType_VolumeTargetTypeDistance:
    case PbVolumeTarget_PbVolymeTargetType_VolumeTargetTypeCalories:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PbStravaSegmentTargets

@implementation PbStravaSegmentTargets

@dynamic hasOwnBest, ownBest;
@dynamic hasKomQom, komQom;

typedef struct PbStravaSegmentTargets__storage_ {
  uint32_t _has_storage_[1];
  PbDuration *ownBest;
  PbDuration *komQom;
} PbStravaSegmentTargets__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ownBest",
        .dataTypeSpecific.className = GPBStringifySymbol(PbDuration),
        .number = PbStravaSegmentTargets_FieldNumber_OwnBest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbStravaSegmentTargets__storage_, ownBest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "komQom",
        .dataTypeSpecific.className = GPBStringifySymbol(PbDuration),
        .number = PbStravaSegmentTargets_FieldNumber_KomQom,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbStravaSegmentTargets__storage_, komQom),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbStravaSegmentTargets class]
                                     rootClass:[StructuresRoot class]
                                          file:StructuresRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbStravaSegmentTargets__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbStravaSegmentTarget

@implementation PbStravaSegmentTarget

@dynamic hasStravaSegmentType, stravaSegmentType;
@dynamic hasStravaSegmentTargets, stravaSegmentTargets;

typedef struct PbStravaSegmentTarget__storage_ {
  uint32_t _has_storage_[1];
  PbStravaSegmentTarget_PbStravaSegmentType stravaSegmentType;
  PbStravaSegmentTargets *stravaSegmentTargets;
} PbStravaSegmentTarget__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = PbStravaSegmentTarget_PbStravaSegmentType_StravaSegmentTypeRide,
        .core.name = "stravaSegmentType",
        .core.dataTypeSpecific.enumDescFunc = PbStravaSegmentTarget_PbStravaSegmentType_EnumDescriptor,
        .core.number = PbStravaSegmentTarget_FieldNumber_StravaSegmentType,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(PbStravaSegmentTarget__storage_, stravaSegmentType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "stravaSegmentTargets",
        .core.dataTypeSpecific.className = GPBStringifySymbol(PbStravaSegmentTargets),
        .core.number = PbStravaSegmentTarget_FieldNumber_StravaSegmentTargets,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(PbStravaSegmentTarget__storage_, stravaSegmentTargets),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbStravaSegmentTarget class]
                                     rootClass:[StructuresRoot class]
                                          file:StructuresRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(PbStravaSegmentTarget__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum PbStravaSegmentTarget_PbStravaSegmentType

GPBEnumDescriptor *PbStravaSegmentTarget_PbStravaSegmentType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "StravaSegmentTypeRide\000StravaSegmentTypeR"
        "un\000";
    static const int32_t values[] = {
        PbStravaSegmentTarget_PbStravaSegmentType_StravaSegmentTypeRide,
        PbStravaSegmentTarget_PbStravaSegmentType_StravaSegmentTypeRun,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbStravaSegmentTarget_PbStravaSegmentType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbStravaSegmentTarget_PbStravaSegmentType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbStravaSegmentTarget_PbStravaSegmentType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbStravaSegmentTarget_PbStravaSegmentType_StravaSegmentTypeRide:
    case PbStravaSegmentTarget_PbStravaSegmentType_StravaSegmentTypeRun:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PbTrainingLoad

@implementation PbTrainingLoad

@dynamic hasTrainingLoadVal, trainingLoadVal;
@dynamic hasRecoveryTime, recoveryTime;
@dynamic hasCarbohydrateConsumption, carbohydrateConsumption;
@dynamic hasProteinConsumption, proteinConsumption;
@dynamic hasFatConsumption, fatConsumption;

typedef struct PbTrainingLoad__storage_ {
  uint32_t _has_storage_[1];
  uint32_t trainingLoadVal;
  uint32_t carbohydrateConsumption;
  uint32_t proteinConsumption;
  uint32_t fatConsumption;
  PbDuration *recoveryTime;
} PbTrainingLoad__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "trainingLoadVal",
        .dataTypeSpecific.className = NULL,
        .number = PbTrainingLoad_FieldNumber_TrainingLoadVal,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbTrainingLoad__storage_, trainingLoadVal),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "recoveryTime",
        .dataTypeSpecific.className = GPBStringifySymbol(PbDuration),
        .number = PbTrainingLoad_FieldNumber_RecoveryTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbTrainingLoad__storage_, recoveryTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "carbohydrateConsumption",
        .dataTypeSpecific.className = NULL,
        .number = PbTrainingLoad_FieldNumber_CarbohydrateConsumption,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PbTrainingLoad__storage_, carbohydrateConsumption),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "proteinConsumption",
        .dataTypeSpecific.className = NULL,
        .number = PbTrainingLoad_FieldNumber_ProteinConsumption,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PbTrainingLoad__storage_, proteinConsumption),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "fatConsumption",
        .dataTypeSpecific.className = NULL,
        .number = PbTrainingLoad_FieldNumber_FatConsumption,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PbTrainingLoad__storage_, fatConsumption),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbTrainingLoad class]
                                     rootClass:[StructuresRoot class]
                                          file:StructuresRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbTrainingLoad__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbHeartRateZone

@implementation PbHeartRateZone

@dynamic hasLowerLimit, lowerLimit;
@dynamic hasHigherLimit, higherLimit;

typedef struct PbHeartRateZone__storage_ {
  uint32_t _has_storage_[1];
  uint32_t lowerLimit;
  uint32_t higherLimit;
} PbHeartRateZone__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "lowerLimit",
        .dataTypeSpecific.className = NULL,
        .number = PbHeartRateZone_FieldNumber_LowerLimit,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbHeartRateZone__storage_, lowerLimit),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "higherLimit",
        .dataTypeSpecific.className = NULL,
        .number = PbHeartRateZone_FieldNumber_HigherLimit,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbHeartRateZone__storage_, higherLimit),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbHeartRateZone class]
                                     rootClass:[StructuresRoot class]
                                          file:StructuresRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbHeartRateZone__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbSpeedZone

@implementation PbSpeedZone

@dynamic hasLowerLimit, lowerLimit;
@dynamic hasHigherLimit, higherLimit;

typedef struct PbSpeedZone__storage_ {
  uint32_t _has_storage_[1];
  float lowerLimit;
  float higherLimit;
} PbSpeedZone__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "lowerLimit",
        .dataTypeSpecific.className = NULL,
        .number = PbSpeedZone_FieldNumber_LowerLimit,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbSpeedZone__storage_, lowerLimit),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "higherLimit",
        .dataTypeSpecific.className = NULL,
        .number = PbSpeedZone_FieldNumber_HigherLimit,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbSpeedZone__storage_, higherLimit),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbSpeedZone class]
                                     rootClass:[StructuresRoot class]
                                          file:StructuresRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbSpeedZone__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbPowerZone

@implementation PbPowerZone

@dynamic hasLowerLimit, lowerLimit;
@dynamic hasHigherLimit, higherLimit;

typedef struct PbPowerZone__storage_ {
  uint32_t _has_storage_[1];
  uint32_t lowerLimit;
  uint32_t higherLimit;
} PbPowerZone__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "lowerLimit",
        .dataTypeSpecific.className = NULL,
        .number = PbPowerZone_FieldNumber_LowerLimit,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbPowerZone__storage_, lowerLimit),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "higherLimit",
        .dataTypeSpecific.className = NULL,
        .number = PbPowerZone_FieldNumber_HigherLimit,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbPowerZone__storage_, higherLimit),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbPowerZone class]
                                     rootClass:[StructuresRoot class]
                                          file:StructuresRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbPowerZone__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbZones

@implementation PbZones

@dynamic heartRateZoneArray, heartRateZoneArray_Count;
@dynamic speedZoneArray, speedZoneArray_Count;
@dynamic powerZoneArray, powerZoneArray_Count;
@dynamic hasHeartRateSettingSource, heartRateSettingSource;
@dynamic hasPowerSettingSource, powerSettingSource;
@dynamic hasSpeedSettingSource, speedSettingSource;

typedef struct PbZones__storage_ {
  uint32_t _has_storage_[1];
  PbHeartRateZoneSettingSource heartRateSettingSource;
  PbPowerZoneSettingSource powerSettingSource;
  PbSpeedZoneSettingSource speedSettingSource;
  NSMutableArray *heartRateZoneArray;
  NSMutableArray *speedZoneArray;
  NSMutableArray *powerZoneArray;
} PbZones__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "heartRateZoneArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PbHeartRateZone),
        .number = PbZones_FieldNumber_HeartRateZoneArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PbZones__storage_, heartRateZoneArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "speedZoneArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PbSpeedZone),
        .number = PbZones_FieldNumber_SpeedZoneArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PbZones__storage_, speedZoneArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "powerZoneArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PbPowerZone),
        .number = PbZones_FieldNumber_PowerZoneArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PbZones__storage_, powerZoneArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "heartRateSettingSource",
        .dataTypeSpecific.enumDescFunc = PbHeartRateZoneSettingSource_EnumDescriptor,
        .number = PbZones_FieldNumber_HeartRateSettingSource,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbZones__storage_, heartRateSettingSource),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "powerSettingSource",
        .dataTypeSpecific.enumDescFunc = PbPowerZoneSettingSource_EnumDescriptor,
        .number = PbZones_FieldNumber_PowerSettingSource,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbZones__storage_, powerSettingSource),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "speedSettingSource",
        .dataTypeSpecific.enumDescFunc = PbSpeedZoneSettingSource_EnumDescriptor,
        .number = PbZones_FieldNumber_SpeedSettingSource,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PbZones__storage_, speedSettingSource),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbZones class]
                                     rootClass:[StructuresRoot class]
                                          file:StructuresRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbZones__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbBleMac

@implementation PbBleMac

@dynamic hasMac, mac;
@dynamic hasType, type;

typedef struct PbBleMac__storage_ {
  uint32_t _has_storage_[1];
  PbMacType type;
  NSData *mac;
} PbBleMac__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mac",
        .dataTypeSpecific.className = NULL,
        .number = PbBleMac_FieldNumber_Mac,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbBleMac__storage_, mac),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PbMacType_EnumDescriptor,
        .number = PbBleMac_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbBleMac__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbBleMac class]
                                     rootClass:[StructuresRoot class]
                                          file:StructuresRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbBleMac__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbBleDeviceName

@implementation PbBleDeviceName

@dynamic hasName, name;

typedef struct PbBleDeviceName__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
} PbBleDeviceName__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PbBleDeviceName_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbBleDeviceName__storage_, name),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbBleDeviceName class]
                                     rootClass:[StructuresRoot class]
                                          file:StructuresRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbBleDeviceName__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbDeviceId

@implementation PbDeviceId

@dynamic hasDeviceId, deviceId;

typedef struct PbDeviceId__storage_ {
  uint32_t _has_storage_[1];
  NSString *deviceId;
} PbDeviceId__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deviceId",
        .dataTypeSpecific.className = NULL,
        .number = PbDeviceId_FieldNumber_DeviceId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbDeviceId__storage_, deviceId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbDeviceId class]
                                     rootClass:[StructuresRoot class]
                                          file:StructuresRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbDeviceId__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbRunningIndex

@implementation PbRunningIndex

@dynamic hasValue, value;
@dynamic hasCalculationTime, calculationTime;

typedef struct PbRunningIndex__storage_ {
  uint32_t _has_storage_[1];
  uint32_t value;
  PbDuration *calculationTime;
} PbRunningIndex__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = PbRunningIndex_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbRunningIndex__storage_, value),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "calculationTime",
        .dataTypeSpecific.className = GPBStringifySymbol(PbDuration),
        .number = PbRunningIndex_FieldNumber_CalculationTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbRunningIndex__storage_, calculationTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbRunningIndex class]
                                     rootClass:[StructuresRoot class]
                                          file:StructuresRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbRunningIndex__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbSportIdentifier

@implementation PbSportIdentifier

@dynamic hasValue, value;

typedef struct PbSportIdentifier__storage_ {
  uint32_t _has_storage_[1];
  uint64_t value;
} PbSportIdentifier__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = PbSportIdentifier_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbSportIdentifier__storage_, value),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbSportIdentifier class]
                                     rootClass:[StructuresRoot class]
                                          file:StructuresRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbSportIdentifier__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbOneLineText

@implementation PbOneLineText

@dynamic hasText, text;

typedef struct PbOneLineText__storage_ {
  uint32_t _has_storage_[1];
  NSString *text;
} PbOneLineText__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.className = NULL,
        .number = PbOneLineText_FieldNumber_Text,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbOneLineText__storage_, text),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbOneLineText class]
                                     rootClass:[StructuresRoot class]
                                          file:StructuresRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbOneLineText__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbMultiLineText

@implementation PbMultiLineText

@dynamic hasText, text;

typedef struct PbMultiLineText__storage_ {
  uint32_t _has_storage_[1];
  NSString *text;
} PbMultiLineText__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.className = NULL,
        .number = PbMultiLineText_FieldNumber_Text,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbMultiLineText__storage_, text),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbMultiLineText class]
                                     rootClass:[StructuresRoot class]
                                          file:StructuresRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbMultiLineText__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbLanguageId

@implementation PbLanguageId

@dynamic hasLanguage, language;

typedef struct PbLanguageId__storage_ {
  uint32_t _has_storage_[1];
  NSString *language;
} PbLanguageId__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "language",
        .dataTypeSpecific.className = NULL,
        .number = PbLanguageId_FieldNumber_Language,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbLanguageId__storage_, language),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbLanguageId class]
                                     rootClass:[StructuresRoot class]
                                          file:StructuresRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbLanguageId__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbTrainingSessionTargetId

@implementation PbTrainingSessionTargetId

@dynamic hasValue, value;
@dynamic hasLastModified, lastModified;

typedef struct PbTrainingSessionTargetId__storage_ {
  uint32_t _has_storage_[1];
  PbSystemDateTime *lastModified;
  uint64_t value;
} PbTrainingSessionTargetId__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = PbTrainingSessionTargetId_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbTrainingSessionTargetId__storage_, value),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "lastModified",
        .dataTypeSpecific.className = GPBStringifySymbol(PbSystemDateTime),
        .number = PbTrainingSessionTargetId_FieldNumber_LastModified,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbTrainingSessionTargetId__storage_, lastModified),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbTrainingSessionTargetId class]
                                     rootClass:[StructuresRoot class]
                                          file:StructuresRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbTrainingSessionTargetId__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbTrainingSessionFavoriteId

@implementation PbTrainingSessionFavoriteId

@dynamic hasValue, value;
@dynamic hasLastModified, lastModified;

typedef struct PbTrainingSessionFavoriteId__storage_ {
  uint32_t _has_storage_[1];
  PbSystemDateTime *lastModified;
  uint64_t value;
} PbTrainingSessionFavoriteId__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = PbTrainingSessionFavoriteId_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbTrainingSessionFavoriteId__storage_, value),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "lastModified",
        .dataTypeSpecific.className = GPBStringifySymbol(PbSystemDateTime),
        .number = PbTrainingSessionFavoriteId_FieldNumber_LastModified,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbTrainingSessionFavoriteId__storage_, lastModified),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbTrainingSessionFavoriteId class]
                                     rootClass:[StructuresRoot class]
                                          file:StructuresRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbTrainingSessionFavoriteId__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbRouteId

@implementation PbRouteId

@dynamic hasValue, value;

typedef struct PbRouteId__storage_ {
  uint32_t _has_storage_[1];
  uint64_t value;
} PbRouteId__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = PbRouteId_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbRouteId__storage_, value),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbRouteId class]
                                     rootClass:[StructuresRoot class]
                                          file:StructuresRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbRouteId__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbSwimmingPoolInfo

@implementation PbSwimmingPoolInfo

@dynamic hasPoolLength, poolLength;
@dynamic hasSwimmingPoolType, swimmingPoolType;

typedef struct PbSwimmingPoolInfo__storage_ {
  uint32_t _has_storage_[1];
  float poolLength;
  PbSwimmingPoolUnits swimmingPoolType;
} PbSwimmingPoolInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "poolLength",
        .dataTypeSpecific.className = NULL,
        .number = PbSwimmingPoolInfo_FieldNumber_PoolLength,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbSwimmingPoolInfo__storage_, poolLength),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "swimmingPoolType",
        .dataTypeSpecific.enumDescFunc = PbSwimmingPoolUnits_EnumDescriptor,
        .number = PbSwimmingPoolInfo_FieldNumber_SwimmingPoolType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbSwimmingPoolInfo__storage_, swimmingPoolType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbSwimmingPoolInfo class]
                                     rootClass:[StructuresRoot class]
                                          file:StructuresRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbSwimmingPoolInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbTrainingProgramId

@implementation PbTrainingProgramId

@dynamic hasValue, value;

typedef struct PbTrainingProgramId__storage_ {
  uint32_t _has_storage_[1];
  uint64_t value;
} PbTrainingProgramId__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = PbTrainingProgramId_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbTrainingProgramId__storage_, value),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbTrainingProgramId class]
                                     rootClass:[StructuresRoot class]
                                          file:StructuresRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbTrainingProgramId__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbEventId

@implementation PbEventId

@dynamic hasValue, value;

typedef struct PbEventId__storage_ {
  uint32_t _has_storage_[1];
  uint64_t value;
} PbEventId__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = PbEventId_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbEventId__storage_, value),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbEventId class]
                                     rootClass:[StructuresRoot class]
                                          file:StructuresRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbEventId__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbPauseTime

@implementation PbPauseTime

@dynamic hasStartTime, startTime;
@dynamic hasDuration, duration;

typedef struct PbPauseTime__storage_ {
  uint32_t _has_storage_[1];
  PbDuration *startTime;
  PbDuration *duration;
} PbPauseTime__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startTime",
        .dataTypeSpecific.className = GPBStringifySymbol(PbDuration),
        .number = PbPauseTime_FieldNumber_StartTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbPauseTime__storage_, startTime),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "duration",
        .dataTypeSpecific.className = GPBStringifySymbol(PbDuration),
        .number = PbPauseTime_FieldNumber_Duration,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbPauseTime__storage_, duration),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbPauseTime class]
                                     rootClass:[StructuresRoot class]
                                          file:StructuresRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbPauseTime__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbApplicationId

@implementation PbApplicationId

@dynamic hasValue, value;

typedef struct PbApplicationId__storage_ {
  uint32_t _has_storage_[1];
  uint64_t value;
} PbApplicationId__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = PbApplicationId_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbApplicationId__storage_, value),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbApplicationId class]
                                     rootClass:[StructuresRoot class]
                                          file:StructuresRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbApplicationId__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbVersion

@implementation PbVersion

@dynamic hasMajor, major;
@dynamic hasMinor, minor;
@dynamic hasPatch, patch;
@dynamic hasSpecifier, specifier;

typedef struct PbVersion__storage_ {
  uint32_t _has_storage_[1];
  uint32_t major;
  uint32_t minor;
  uint32_t patch;
  NSString *specifier;
} PbVersion__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "major",
        .dataTypeSpecific.className = NULL,
        .number = PbVersion_FieldNumber_Major,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbVersion__storage_, major),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "minor",
        .dataTypeSpecific.className = NULL,
        .number = PbVersion_FieldNumber_Minor,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbVersion__storage_, minor),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "patch",
        .dataTypeSpecific.className = NULL,
        .number = PbVersion_FieldNumber_Patch,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PbVersion__storage_, patch),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "specifier",
        .dataTypeSpecific.className = NULL,
        .number = PbVersion_FieldNumber_Specifier,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PbVersion__storage_, specifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbVersion class]
                                     rootClass:[StructuresRoot class]
                                          file:StructuresRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbVersion__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbSubcomponentInfo

@implementation PbSubcomponentInfo

@dynamic hasName, name;
@dynamic hasObsoleteRequiredVersion, obsoleteRequiredVersion;
@dynamic hasVersion, version;

typedef struct PbSubcomponentInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  PbVersion *obsoleteRequiredVersion;
  PbVersion *version;
} PbSubcomponentInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PbSubcomponentInfo_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbSubcomponentInfo__storage_, name),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "obsoleteRequiredVersion",
        .dataTypeSpecific.className = GPBStringifySymbol(PbVersion),
        .number = PbSubcomponentInfo_FieldNumber_ObsoleteRequiredVersion,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbSubcomponentInfo__storage_, obsoleteRequiredVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = GPBStringifySymbol(PbVersion),
        .number = PbSubcomponentInfo_FieldNumber_Version,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PbSubcomponentInfo__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbSubcomponentInfo class]
                                     rootClass:[StructuresRoot class]
                                          file:StructuresRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbSubcomponentInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002h\250\247\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbBleUuid

@implementation PbBleUuid

@dynamic hasUuid, uuid;

typedef struct PbBleUuid__storage_ {
  uint32_t _has_storage_[1];
  NSData *uuid;
} PbBleUuid__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = PbBleUuid_FieldNumber_Uuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbBleUuid__storage_, uuid),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbBleUuid class]
                                     rootClass:[StructuresRoot class]
                                          file:StructuresRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbBleUuid__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbBleCharacteristic

@implementation PbBleCharacteristic

@dynamic hasHandle, handle;
@dynamic hasType, type;

typedef struct PbBleCharacteristic__storage_ {
  uint32_t _has_storage_[1];
  uint32_t handle;
  PbBleUuid *type;
} PbBleCharacteristic__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "handle",
        .dataTypeSpecific.className = NULL,
        .number = PbBleCharacteristic_FieldNumber_Handle,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbBleCharacteristic__storage_, handle),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = GPBStringifySymbol(PbBleUuid),
        .number = PbBleCharacteristic_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbBleCharacteristic__storage_, type),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbBleCharacteristic class]
                                     rootClass:[StructuresRoot class]
                                          file:StructuresRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbBleCharacteristic__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbBleService

@implementation PbBleService

@dynamic hasServiceUuid, serviceUuid;
@dynamic characteristicsArray, characteristicsArray_Count;

typedef struct PbBleService__storage_ {
  uint32_t _has_storage_[1];
  PbBleUuid *serviceUuid;
  NSMutableArray *characteristicsArray;
} PbBleService__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "serviceUuid",
        .dataTypeSpecific.className = GPBStringifySymbol(PbBleUuid),
        .number = PbBleService_FieldNumber_ServiceUuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbBleService__storage_, serviceUuid),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "characteristicsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PbBleCharacteristic),
        .number = PbBleService_FieldNumber_CharacteristicsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PbBleService__storage_, characteristicsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbBleService class]
                                     rootClass:[StructuresRoot class]
                                          file:StructuresRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbBleService__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbSourceDevice

@implementation PbSourceDevice

@dynamic hasName, name;
@dynamic hasManufacturer, manufacturer;
@dynamic hasModelNumber, modelNumber;
@dynamic hasHardwareCode, hardwareCode;
@dynamic hasPlatformVersion, platformVersion;
@dynamic hasSoftwareVersion, softwareVersion;
@dynamic hasPolarmathsmartVersion, polarmathsmartVersion;
@dynamic hasCollector, collector;

typedef struct PbSourceDevice__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *manufacturer;
  NSString *modelNumber;
  NSString *hardwareCode;
  PbVersion *platformVersion;
  PbVersion *softwareVersion;
  PbVersion *polarmathsmartVersion;
  PbSourceDevice *collector;
} PbSourceDevice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PbSourceDevice_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbSourceDevice__storage_, name),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "manufacturer",
        .dataTypeSpecific.className = NULL,
        .number = PbSourceDevice_FieldNumber_Manufacturer,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbSourceDevice__storage_, manufacturer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "modelNumber",
        .dataTypeSpecific.className = NULL,
        .number = PbSourceDevice_FieldNumber_ModelNumber,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PbSourceDevice__storage_, modelNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hardwareCode",
        .dataTypeSpecific.className = NULL,
        .number = PbSourceDevice_FieldNumber_HardwareCode,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PbSourceDevice__storage_, hardwareCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "platformVersion",
        .dataTypeSpecific.className = GPBStringifySymbol(PbVersion),
        .number = PbSourceDevice_FieldNumber_PlatformVersion,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PbSourceDevice__storage_, platformVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "softwareVersion",
        .dataTypeSpecific.className = GPBStringifySymbol(PbVersion),
        .number = PbSourceDevice_FieldNumber_SoftwareVersion,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PbSourceDevice__storage_, softwareVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "polarmathsmartVersion",
        .dataTypeSpecific.className = GPBStringifySymbol(PbVersion),
        .number = PbSourceDevice_FieldNumber_PolarmathsmartVersion,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PbSourceDevice__storage_, polarmathsmartVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "collector",
        .dataTypeSpecific.className = GPBStringifySymbol(PbSourceDevice),
        .number = PbSourceDevice_FieldNumber_Collector,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PbSourceDevice__storage_, collector),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbSourceDevice class]
                                     rootClass:[StructuresRoot class]
                                          file:StructuresRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbSourceDevice__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbSampleSourceDevice

@implementation PbSampleSourceDevice

@dynamic hasStartIndex, startIndex;
@dynamic hasSourceDevice, sourceDevice;

typedef struct PbSampleSourceDevice__storage_ {
  uint32_t _has_storage_[1];
  uint32_t startIndex;
  PbSourceDevice *sourceDevice;
} PbSampleSourceDevice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startIndex",
        .dataTypeSpecific.className = NULL,
        .number = PbSampleSourceDevice_FieldNumber_StartIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbSampleSourceDevice__storage_, startIndex),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "sourceDevice",
        .dataTypeSpecific.className = GPBStringifySymbol(PbSourceDevice),
        .number = PbSampleSourceDevice_FieldNumber_SourceDevice,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbSampleSourceDevice__storage_, sourceDevice),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbSampleSourceDevice class]
                                     rootClass:[StructuresRoot class]
                                          file:StructuresRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbSampleSourceDevice__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
