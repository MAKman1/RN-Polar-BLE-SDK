// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: types.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Types.pbobjc.h"
 #import "Descriptor.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - TypesRoot

@implementation TypesRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    registry = [[GPBExtensionRegistry alloc] init];
    static GPBExtensionDescription descriptions[] = {
      {
        .defaultValue.valueEnum = PbDataType_Undefined,
        .singletonName = GPBStringifySymbol(TypesRoot_type),
        .extendedClass = GPBStringifySymbol(GPBFieldOptions),
        .messageOrGroupClassName = NULL,
        .enumDescriptorFunc = PbDataType_EnumDescriptor,
        .fieldNumber = 50000,
        .dataType = GPBDataTypeEnum,
        .options = GPBExtensionNone,
      },
      {
        .defaultValue.valueBool = NO,
        .singletonName = GPBStringifySymbol(TypesRoot_isUnion),
        .extendedClass = GPBStringifySymbol(GPBMessageOptions),
        .messageOrGroupClassName = NULL,
        .enumDescriptorFunc = NULL,
        .fieldNumber = 50001,
        .dataType = GPBDataTypeBool,
        .options = GPBExtensionNone,
      },
      {
        .defaultValue.valueMessage = nil,
        .singletonName = GPBStringifySymbol(TypesRoot_range),
        .extendedClass = GPBStringifySymbol(GPBFieldOptions),
        .messageOrGroupClassName = GPBStringifySymbol(PbRangeOptions),
        .enumDescriptorFunc = NULL,
        .fieldNumber = 50003,
        .dataType = GPBDataTypeMessage,
        .options = GPBExtensionNone,
      },
    };
    for (size_t i = 0; i < sizeof(descriptions) / sizeof(descriptions[0]); ++i) {
      GPBExtensionDescriptor *extension =
          [[GPBExtensionDescriptor alloc] initWithExtensionDescription:&descriptions[i]];
      [registry addExtension:extension];
      [self globallyRegisterExtension:extension];
      [extension release];
    }
    // None of the imports (direct or indirect) defined extensions, so no need to add
    // them to this registry.
  }
  return registry;
}

@end

#pragma mark - TypesRoot_FileDescriptor

static GPBFileDescriptor *TypesRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@""
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - Enum PbDataType

GPBEnumDescriptor *PbDataType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Undefined\000Inherited\000Enum\000Millis\000Second\000M"
        "inute\000Hour\000Hours\000Day\000Month\000Year\000Weight\000H"
        "eight\000Vo2Max\000Heartrate\000HrPercent\000HrReser"
        "ve\000Speed\000Cadence\000Altitude\000Power\000PowerLrb"
        "\000PowerPi\000Temperature\000Activity\000StrideLeng"
        "th\000Incline\000Decline\000Distance\000Energy\000FatPe"
        "rcents\000Ascent\000Descent\000Latitude\000Longitude"
        "\000Hertz\000Percent\000CumulatedActivityDay\000Runn"
        "ingIndex\000RrInterval\000ZIndex\000ExerciseTarge"
        "tIndex\000TimeZoneOffset\000WheelSize\000FitnessC"
        "lass\000Acceleration\000CrankLength\000AngleDegre"
        "e\000Newton\000FunctionalThresholdPower\000Calori"
        "es\000SpeedCalibrationOffset\000Week\000CardioLoa"
        "d\000MaximumAerobicPower\000MaximumAerobicSpee"
        "d\000MuscleLoad\000PerceivedLoad\000";
    static const int32_t values[] = {
        PbDataType_Undefined,
        PbDataType_Inherited,
        PbDataType_Enum,
        PbDataType_Millis,
        PbDataType_Second,
        PbDataType_Minute,
        PbDataType_Hour,
        PbDataType_Hours,
        PbDataType_Day,
        PbDataType_Month,
        PbDataType_Year,
        PbDataType_Weight,
        PbDataType_Height,
        PbDataType_Vo2Max,
        PbDataType_Heartrate,
        PbDataType_HrPercent,
        PbDataType_HrReserve,
        PbDataType_Speed,
        PbDataType_Cadence,
        PbDataType_Altitude,
        PbDataType_Power,
        PbDataType_PowerLrb,
        PbDataType_PowerPi,
        PbDataType_Temperature,
        PbDataType_Activity,
        PbDataType_StrideLength,
        PbDataType_Incline,
        PbDataType_Decline,
        PbDataType_Distance,
        PbDataType_Energy,
        PbDataType_FatPercents,
        PbDataType_Ascent,
        PbDataType_Descent,
        PbDataType_Latitude,
        PbDataType_Longitude,
        PbDataType_Hertz,
        PbDataType_Percent,
        PbDataType_CumulatedActivityDay,
        PbDataType_RunningIndex,
        PbDataType_RrInterval,
        PbDataType_ZIndex,
        PbDataType_ExerciseTargetIndex,
        PbDataType_TimeZoneOffset,
        PbDataType_WheelSize,
        PbDataType_FitnessClass,
        PbDataType_Acceleration,
        PbDataType_CrankLength,
        PbDataType_AngleDegree,
        PbDataType_Newton,
        PbDataType_FunctionalThresholdPower,
        PbDataType_Calories,
        PbDataType_SpeedCalibrationOffset,
        PbDataType_Week,
        PbDataType_CardioLoad,
        PbDataType_MaximumAerobicPower,
        PbDataType_MaximumAerobicSpeed,
        PbDataType_MuscleLoad,
        PbDataType_PerceivedLoad,
    };
    static const char *extraTextFormatInfo = "\001\rb\002b\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbDataType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbDataType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbDataType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbDataType_Undefined:
    case PbDataType_Inherited:
    case PbDataType_Enum:
    case PbDataType_Millis:
    case PbDataType_Second:
    case PbDataType_Minute:
    case PbDataType_Hour:
    case PbDataType_Hours:
    case PbDataType_Day:
    case PbDataType_Month:
    case PbDataType_Year:
    case PbDataType_Weight:
    case PbDataType_Height:
    case PbDataType_Vo2Max:
    case PbDataType_Heartrate:
    case PbDataType_HrPercent:
    case PbDataType_HrReserve:
    case PbDataType_Speed:
    case PbDataType_Cadence:
    case PbDataType_Altitude:
    case PbDataType_Power:
    case PbDataType_PowerLrb:
    case PbDataType_PowerPi:
    case PbDataType_Temperature:
    case PbDataType_Activity:
    case PbDataType_StrideLength:
    case PbDataType_Incline:
    case PbDataType_Decline:
    case PbDataType_Distance:
    case PbDataType_Energy:
    case PbDataType_FatPercents:
    case PbDataType_Ascent:
    case PbDataType_Descent:
    case PbDataType_Latitude:
    case PbDataType_Longitude:
    case PbDataType_Hertz:
    case PbDataType_Percent:
    case PbDataType_CumulatedActivityDay:
    case PbDataType_RunningIndex:
    case PbDataType_RrInterval:
    case PbDataType_ZIndex:
    case PbDataType_ExerciseTargetIndex:
    case PbDataType_TimeZoneOffset:
    case PbDataType_WheelSize:
    case PbDataType_FitnessClass:
    case PbDataType_Acceleration:
    case PbDataType_CrankLength:
    case PbDataType_AngleDegree:
    case PbDataType_Newton:
    case PbDataType_FunctionalThresholdPower:
    case PbDataType_Calories:
    case PbDataType_SpeedCalibrationOffset:
    case PbDataType_Week:
    case PbDataType_CardioLoad:
    case PbDataType_MaximumAerobicPower:
    case PbDataType_MaximumAerobicSpeed:
    case PbDataType_MuscleLoad:
    case PbDataType_PerceivedLoad:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PbHeartRateView

GPBEnumDescriptor *PbHeartRateView_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "HeartRateViewBpm\000HeartRateViewPercentsOf"
        "HrReserve\000HeartRateViewPercentsOfMaxHr\000";
    static const int32_t values[] = {
        PbHeartRateView_HeartRateViewBpm,
        PbHeartRateView_HeartRateViewPercentsOfHrReserve,
        PbHeartRateView_HeartRateViewPercentsOfMaxHr,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbHeartRateView)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbHeartRateView_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbHeartRateView_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbHeartRateView_HeartRateViewBpm:
    case PbHeartRateView_HeartRateViewPercentsOfHrReserve:
    case PbHeartRateView_HeartRateViewPercentsOfMaxHr:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PbUnitSystem

GPBEnumDescriptor *PbUnitSystem_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Metric\000Imperial\000";
    static const int32_t values[] = {
        PbUnitSystem_Metric,
        PbUnitSystem_Imperial,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbUnitSystem)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbUnitSystem_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbUnitSystem_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbUnitSystem_Metric:
    case PbUnitSystem_Imperial:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PbTimeSelection

GPBEnumDescriptor *PbTimeSelection_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Time1\000Time2\000";
    static const int32_t values[] = {
        PbTimeSelection_Time1,
        PbTimeSelection_Time2,
    };
    static const char *extraTextFormatInfo = "\002\000d\201\000\001d\201\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbTimeSelection)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbTimeSelection_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbTimeSelection_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbTimeSelection_Time1:
    case PbTimeSelection_Time2:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PbTimeFormat

GPBEnumDescriptor *PbTimeFormat_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "TimeFormat24H\000TimeFormat12H\000";
    static const int32_t values[] = {
        PbTimeFormat_TimeFormat24H,
        PbTimeFormat_TimeFormat12H,
    };
    static const char *extraTextFormatInfo = "\002\000d\346\203\000\001d\346\203\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbTimeFormat)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbTimeFormat_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbTimeFormat_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbTimeFormat_TimeFormat24H:
    case PbTimeFormat_TimeFormat12H:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PbTimeFormatSeparator

GPBEnumDescriptor *PbTimeFormatSeparator_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "TimeFormatSeparatorDot\000TimeFormatSeparat"
        "orColon\000";
    static const int32_t values[] = {
        PbTimeFormatSeparator_TimeFormatSeparatorDot,
        PbTimeFormatSeparator_TimeFormatSeparatorColon,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbTimeFormatSeparator)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbTimeFormatSeparator_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbTimeFormatSeparator_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbTimeFormatSeparator_TimeFormatSeparatorDot:
    case PbTimeFormatSeparator_TimeFormatSeparatorColon:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PbStartDayOfWeek

GPBEnumDescriptor *PbStartDayOfWeek_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Monday\000Saturday\000Sunday\000";
    static const int32_t values[] = {
        PbStartDayOfWeek_Monday,
        PbStartDayOfWeek_Saturday,
        PbStartDayOfWeek_Sunday,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbStartDayOfWeek)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbStartDayOfWeek_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbStartDayOfWeek_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbStartDayOfWeek_Monday:
    case PbStartDayOfWeek_Saturday:
    case PbStartDayOfWeek_Sunday:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PbDateFormatSeparator

GPBEnumDescriptor *PbDateFormatSeparator_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Dot\000Slash\000Hyphen\000";
    static const int32_t values[] = {
        PbDateFormatSeparator_Dot,
        PbDateFormatSeparator_Slash,
        PbDateFormatSeparator_Hyphen,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbDateFormatSeparator)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbDateFormatSeparator_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbDateFormatSeparator_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbDateFormatSeparator_Dot:
    case PbDateFormatSeparator_Slash:
    case PbDateFormatSeparator_Hyphen:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PbDateFormat

GPBEnumDescriptor *PbDateFormat_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "DdMmYyyy\000MmDdYyyy\000YyyyMmDd\000";
    static const int32_t values[] = {
        PbDateFormat_DdMmYyyy,
        PbDateFormat_MmDdYyyy,
        PbDateFormat_YyyyMmDd,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbDateFormat)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbDateFormat_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbDateFormat_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbDateFormat_DdMmYyyy:
    case PbDateFormat_MmDdYyyy:
    case PbDateFormat_YyyyMmDd:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PbFeatureType

GPBEnumDescriptor *PbFeatureType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "FeatureTypeHeartRate\000FeatureTypeRrInterv"
        "al\000FeatureTypeSpeed\000FeatureTypeDistance\000"
        "FeatureTypeBikeCadence\000FeatureTypeBikePo"
        "wer\000FeatureTypeGpsLocation\000FeatureTypeRu"
        "nningCadence\000FeatureTypePressTemperature"
        "\000FeatureTypeAltitude\000FeatureTypeSteps\000Fe"
        "atureTypeActivity\000FeatureTypeStrideLengt"
        "h\000FeatureTypeRscMovingType\000FeatureTypeJu"
        "mpHeigth\000FeatureTypeCompassHeading\000Featu"
        "reTypeGpsSpeed\000FeatureTypeGpsDistance\000Fe"
        "atureTypeGpsAltitude\000FeatureTypeBikeWhee"
        "lRevolution\000FeatureTypeBikeCrankRevoluti"
        "on\000FeatureTypeAsSpeed\000FeatureTypeAsCaden"
        "ce\000FeatureTypeAsDistance\000FeatureTypeAsSw"
        "rState\000FeatureTypeBatteryLevel\000FeatureTy"
        "peFileTransfer\000FeatureTypePushNotificati"
        "ons\000FeatureTypeWeightScale\000FeatureTypeRe"
        "moteButtons\000FeatureTypeGopro\000FeatureType"
        "PpInterval\000";
    static const int32_t values[] = {
        PbFeatureType_FeatureTypeHeartRate,
        PbFeatureType_FeatureTypeRrInterval,
        PbFeatureType_FeatureTypeSpeed,
        PbFeatureType_FeatureTypeDistance,
        PbFeatureType_FeatureTypeBikeCadence,
        PbFeatureType_FeatureTypeBikePower,
        PbFeatureType_FeatureTypeGpsLocation,
        PbFeatureType_FeatureTypeRunningCadence,
        PbFeatureType_FeatureTypePressTemperature,
        PbFeatureType_FeatureTypeAltitude,
        PbFeatureType_FeatureTypeSteps,
        PbFeatureType_FeatureTypeActivity,
        PbFeatureType_FeatureTypeStrideLength,
        PbFeatureType_FeatureTypeRscMovingType,
        PbFeatureType_FeatureTypeJumpHeigth,
        PbFeatureType_FeatureTypeCompassHeading,
        PbFeatureType_FeatureTypeGpsSpeed,
        PbFeatureType_FeatureTypeGpsDistance,
        PbFeatureType_FeatureTypeGpsAltitude,
        PbFeatureType_FeatureTypeBikeWheelRevolution,
        PbFeatureType_FeatureTypeBikeCrankRevolution,
        PbFeatureType_FeatureTypeAsSpeed,
        PbFeatureType_FeatureTypeAsCadence,
        PbFeatureType_FeatureTypeAsDistance,
        PbFeatureType_FeatureTypeAsSwrState,
        PbFeatureType_FeatureTypeBatteryLevel,
        PbFeatureType_FeatureTypeFileTransfer,
        PbFeatureType_FeatureTypePushNotifications,
        PbFeatureType_FeatureTypeWeightScale,
        PbFeatureType_FeatureTypeRemoteButtons,
        PbFeatureType_FeatureTypeGopro,
        PbFeatureType_FeatureTypePpInterval,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbFeatureType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbFeatureType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbFeatureType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbFeatureType_FeatureTypeHeartRate:
    case PbFeatureType_FeatureTypeRrInterval:
    case PbFeatureType_FeatureTypeSpeed:
    case PbFeatureType_FeatureTypeDistance:
    case PbFeatureType_FeatureTypeBikeCadence:
    case PbFeatureType_FeatureTypeBikePower:
    case PbFeatureType_FeatureTypeGpsLocation:
    case PbFeatureType_FeatureTypeRunningCadence:
    case PbFeatureType_FeatureTypePressTemperature:
    case PbFeatureType_FeatureTypeAltitude:
    case PbFeatureType_FeatureTypeSteps:
    case PbFeatureType_FeatureTypeActivity:
    case PbFeatureType_FeatureTypeStrideLength:
    case PbFeatureType_FeatureTypeRscMovingType:
    case PbFeatureType_FeatureTypeJumpHeigth:
    case PbFeatureType_FeatureTypeCompassHeading:
    case PbFeatureType_FeatureTypeGpsSpeed:
    case PbFeatureType_FeatureTypeGpsDistance:
    case PbFeatureType_FeatureTypeGpsAltitude:
    case PbFeatureType_FeatureTypeBikeWheelRevolution:
    case PbFeatureType_FeatureTypeBikeCrankRevolution:
    case PbFeatureType_FeatureTypeAsSpeed:
    case PbFeatureType_FeatureTypeAsCadence:
    case PbFeatureType_FeatureTypeAsDistance:
    case PbFeatureType_FeatureTypeAsSwrState:
    case PbFeatureType_FeatureTypeBatteryLevel:
    case PbFeatureType_FeatureTypeFileTransfer:
    case PbFeatureType_FeatureTypePushNotifications:
    case PbFeatureType_FeatureTypeWeightScale:
    case PbFeatureType_FeatureTypeRemoteButtons:
    case PbFeatureType_FeatureTypeGopro:
    case PbFeatureType_FeatureTypePpInterval:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PbMovingType

GPBEnumDescriptor *PbMovingType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Walking\000Running\000Standing\000";
    static const int32_t values[] = {
        PbMovingType_Walking,
        PbMovingType_Running,
        PbMovingType_Standing,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbMovingType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbMovingType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbMovingType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbMovingType_Walking:
    case PbMovingType_Running:
    case PbMovingType_Standing:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PbOperationType

GPBEnumDescriptor *PbOperationType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Multiply\000Sum\000";
    static const int32_t values[] = {
        PbOperationType_Multiply,
        PbOperationType_Sum,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbOperationType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbOperationType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbOperationType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbOperationType_Multiply:
    case PbOperationType_Sum:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PbExerciseFeedback

GPBEnumDescriptor *PbExerciseFeedback_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "FeedbackNone\000Feedback1\000Feedback2\000Feedbac"
        "k3\000Feedback4\000Feedback5\000Feedback6\000Feedbac"
        "k7\000Feedback8\000Feedback9\000Feedback10\000Feedba"
        "ck11\000Feedback12\000Feedback13\000Feedback14\000Fe"
        "edback15\000Feedback16\000Feedback17\000";
    static const int32_t values[] = {
        PbExerciseFeedback_FeedbackNone,
        PbExerciseFeedback_Feedback1,
        PbExerciseFeedback_Feedback2,
        PbExerciseFeedback_Feedback3,
        PbExerciseFeedback_Feedback4,
        PbExerciseFeedback_Feedback5,
        PbExerciseFeedback_Feedback6,
        PbExerciseFeedback_Feedback7,
        PbExerciseFeedback_Feedback8,
        PbExerciseFeedback_Feedback9,
        PbExerciseFeedback_Feedback10,
        PbExerciseFeedback_Feedback11,
        PbExerciseFeedback_Feedback12,
        PbExerciseFeedback_Feedback13,
        PbExerciseFeedback_Feedback14,
        PbExerciseFeedback_Feedback15,
        PbExerciseFeedback_Feedback16,
        PbExerciseFeedback_Feedback17,
    };
    static const char *extraTextFormatInfo = "\021\001h\201\000\002h\201\000\003h\201\000\004h\201\000\005h\201\000\006h\201\000\007h\201\000\010h\201\000\th\201\000\nh\202\000\013h\202\000\014h\202\000\rh\202\000\016h\202\000\017h\202\000\020h\202\000\021h\202\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbExerciseFeedback)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbExerciseFeedback_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbExerciseFeedback_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbExerciseFeedback_FeedbackNone:
    case PbExerciseFeedback_Feedback1:
    case PbExerciseFeedback_Feedback2:
    case PbExerciseFeedback_Feedback3:
    case PbExerciseFeedback_Feedback4:
    case PbExerciseFeedback_Feedback5:
    case PbExerciseFeedback_Feedback6:
    case PbExerciseFeedback_Feedback7:
    case PbExerciseFeedback_Feedback8:
    case PbExerciseFeedback_Feedback9:
    case PbExerciseFeedback_Feedback10:
    case PbExerciseFeedback_Feedback11:
    case PbExerciseFeedback_Feedback12:
    case PbExerciseFeedback_Feedback13:
    case PbExerciseFeedback_Feedback14:
    case PbExerciseFeedback_Feedback15:
    case PbExerciseFeedback_Feedback16:
    case PbExerciseFeedback_Feedback17:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PbHeartRateZoneSettingSource

GPBEnumDescriptor *PbHeartRateZoneSettingSource_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "HeartRateZoneSettingSourceDefault\000HeartR"
        "ateZoneSettingSourceThreshold\000HeartRateZ"
        "oneSettingSourceFree\000";
    static const int32_t values[] = {
        PbHeartRateZoneSettingSource_HeartRateZoneSettingSourceDefault,
        PbHeartRateZoneSettingSource_HeartRateZoneSettingSourceThreshold,
        PbHeartRateZoneSettingSource_HeartRateZoneSettingSourceFree,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbHeartRateZoneSettingSource)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbHeartRateZoneSettingSource_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbHeartRateZoneSettingSource_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbHeartRateZoneSettingSource_HeartRateZoneSettingSourceDefault:
    case PbHeartRateZoneSettingSource_HeartRateZoneSettingSourceThreshold:
    case PbHeartRateZoneSettingSource_HeartRateZoneSettingSourceFree:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PbPowerZoneSettingSource

GPBEnumDescriptor *PbPowerZoneSettingSource_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "PowerZoneSettingSourceDefault\000PowerZoneS"
        "ettingSourceFree\000";
    static const int32_t values[] = {
        PbPowerZoneSettingSource_PowerZoneSettingSourceDefault,
        PbPowerZoneSettingSource_PowerZoneSettingSourceFree,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbPowerZoneSettingSource)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbPowerZoneSettingSource_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbPowerZoneSettingSource_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbPowerZoneSettingSource_PowerZoneSettingSourceDefault:
    case PbPowerZoneSettingSource_PowerZoneSettingSourceFree:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PbSpeedZoneSettingSource

GPBEnumDescriptor *PbSpeedZoneSettingSource_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "SpeedZoneSettingSourceDefault\000SpeedZoneS"
        "ettingSourceFree\000";
    static const int32_t values[] = {
        PbSpeedZoneSettingSource_SpeedZoneSettingSourceDefault,
        PbSpeedZoneSettingSource_SpeedZoneSettingSourceFree,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbSpeedZoneSettingSource)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbSpeedZoneSettingSource_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbSpeedZoneSettingSource_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbSpeedZoneSettingSource_SpeedZoneSettingSourceDefault:
    case PbSpeedZoneSettingSource_SpeedZoneSettingSourceFree:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PbMacType

GPBEnumDescriptor *PbMacType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "MacTypePublic\000MacTypeStatic\000MacTypePriva"
        "teNonresolvable\000MacTypePrivateResolvable"
        "\000MacTypeBtClassic\000";
    static const int32_t values[] = {
        PbMacType_MacTypePublic,
        PbMacType_MacTypeStatic,
        PbMacType_MacTypePrivateNonresolvable,
        PbMacType_MacTypePrivateResolvable,
        PbMacType_MacTypeBtClassic,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbMacType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbMacType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbMacType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbMacType_MacTypePublic:
    case PbMacType_MacTypeStatic:
    case PbMacType_MacTypePrivateNonresolvable:
    case PbMacType_MacTypePrivateResolvable:
    case PbMacType_MacTypeBtClassic:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PbSwimmingStyle

GPBEnumDescriptor *PbSwimmingStyle_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Other\000Turn\000OtherSwimming\000Freestyle\000Breas"
        "tstroke\000Backstroke\000Butterfly\000Drill\000";
    static const int32_t values[] = {
        PbSwimmingStyle_Other,
        PbSwimmingStyle_Turn,
        PbSwimmingStyle_OtherSwimming,
        PbSwimmingStyle_Freestyle,
        PbSwimmingStyle_Breaststroke,
        PbSwimmingStyle_Backstroke,
        PbSwimmingStyle_Butterfly,
        PbSwimmingStyle_Drill,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbSwimmingStyle)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbSwimmingStyle_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbSwimmingStyle_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbSwimmingStyle_Other:
    case PbSwimmingStyle_Turn:
    case PbSwimmingStyle_OtherSwimming:
    case PbSwimmingStyle_Freestyle:
    case PbSwimmingStyle_Breaststroke:
    case PbSwimmingStyle_Backstroke:
    case PbSwimmingStyle_Butterfly:
    case PbSwimmingStyle_Drill:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PbSwimmingPoolUnits

GPBEnumDescriptor *PbSwimmingPoolUnits_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "SwimmingPoolMeters\000SwimmingPoolYards\000";
    static const int32_t values[] = {
        PbSwimmingPoolUnits_SwimmingPoolMeters,
        PbSwimmingPoolUnits_SwimmingPoolYards,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbSwimmingPoolUnits)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbSwimmingPoolUnits_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbSwimmingPoolUnits_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbSwimmingPoolUnits_SwimmingPoolMeters:
    case PbSwimmingPoolUnits_SwimmingPoolYards:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PbExerciseTargetType

GPBEnumDescriptor *PbExerciseTargetType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "ExerciseTargetTypeFree\000ExerciseTargetTyp"
        "eVolume\000ExerciseTargetTypePhased\000Exercis"
        "eTargetTypeRoute\000ExerciseTargetTypeStead"
        "yRacePace\000ExerciseTargetTypeRouteRacePac"
        "e\000ExerciseTargetTypeStravaSegment\000";
    static const int32_t values[] = {
        PbExerciseTargetType_ExerciseTargetTypeFree,
        PbExerciseTargetType_ExerciseTargetTypeVolume,
        PbExerciseTargetType_ExerciseTargetTypePhased,
        PbExerciseTargetType_ExerciseTargetTypeRoute,
        PbExerciseTargetType_ExerciseTargetTypeSteadyRacePace,
        PbExerciseTargetType_ExerciseTargetTypeRouteRacePace,
        PbExerciseTargetType_ExerciseTargetTypeStravaSegment,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbExerciseTargetType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbExerciseTargetType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbExerciseTargetType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbExerciseTargetType_ExerciseTargetTypeFree:
    case PbExerciseTargetType_ExerciseTargetTypeVolume:
    case PbExerciseTargetType_ExerciseTargetTypePhased:
    case PbExerciseTargetType_ExerciseTargetTypeRoute:
    case PbExerciseTargetType_ExerciseTargetTypeSteadyRacePace:
    case PbExerciseTargetType_ExerciseTargetTypeRouteRacePace:
    case PbExerciseTargetType_ExerciseTargetTypeStravaSegment:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Buttons

GPBEnumDescriptor *Buttons_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "ButtonPlus\000ButtonMinus\000ButtonOk\000ButtonLi"
        "ght\000ButtonBack\000";
    static const int32_t values[] = {
        Buttons_ButtonPlus,
        Buttons_ButtonMinus,
        Buttons_ButtonOk,
        Buttons_ButtonLight,
        Buttons_ButtonBack,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Buttons)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Buttons_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Buttons_IsValidValue(int32_t value__) {
  switch (value__) {
    case Buttons_ButtonPlus:
    case Buttons_ButtonMinus:
    case Buttons_ButtonOk:
    case Buttons_ButtonLight:
    case Buttons_ButtonBack:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ButtonState

GPBEnumDescriptor *ButtonState_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "ButtonPressed\000ButtonReleased\000";
    static const int32_t values[] = {
        ButtonState_ButtonPressed,
        ButtonState_ButtonReleased,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ButtonState)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ButtonState_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ButtonState_IsValidValue(int32_t value__) {
  switch (value__) {
    case ButtonState_ButtonPressed:
    case ButtonState_ButtonReleased:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PbSampleType

GPBEnumDescriptor *PbSampleType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "SampleTypeUndefined\000SampleTypeHeartRate\000"
        "SampleTypeCadence\000SampleTypeAltitude\000Sam"
        "pleTypeAltitudeCalibration\000SampleTypeTem"
        "perature\000SampleTypeSpeed\000SampleTypeDista"
        "nce\000SampleTypeStrideLength\000SampleTypeStr"
        "ideCalibration\000SampleTypeForwardAccelera"
        "tion\000SampleTypeMovingType\000SampleTypeLeft"
        "PedalPower\000SampleTypeRightPedalPower\000Sam"
        "pleTypeLeftPedalPowerCalibration\000SampleT"
        "ypeRightPedalPowerCalibration\000SampleType"
        "RrInterval\000SampleTypeAccelerationMad\000";
    static const int32_t values[] = {
        PbSampleType_SampleTypeUndefined,
        PbSampleType_SampleTypeHeartRate,
        PbSampleType_SampleTypeCadence,
        PbSampleType_SampleTypeAltitude,
        PbSampleType_SampleTypeAltitudeCalibration,
        PbSampleType_SampleTypeTemperature,
        PbSampleType_SampleTypeSpeed,
        PbSampleType_SampleTypeDistance,
        PbSampleType_SampleTypeStrideLength,
        PbSampleType_SampleTypeStrideCalibration,
        PbSampleType_SampleTypeForwardAcceleration,
        PbSampleType_SampleTypeMovingType,
        PbSampleType_SampleTypeLeftPedalPower,
        PbSampleType_SampleTypeRightPedalPower,
        PbSampleType_SampleTypeLeftPedalPowerCalibration,
        PbSampleType_SampleTypeRightPedalPowerCalibration,
        PbSampleType_SampleTypeRrInterval,
        PbSampleType_SampleTypeAccelerationMad,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbSampleType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbSampleType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbSampleType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbSampleType_SampleTypeUndefined:
    case PbSampleType_SampleTypeHeartRate:
    case PbSampleType_SampleTypeCadence:
    case PbSampleType_SampleTypeAltitude:
    case PbSampleType_SampleTypeAltitudeCalibration:
    case PbSampleType_SampleTypeTemperature:
    case PbSampleType_SampleTypeSpeed:
    case PbSampleType_SampleTypeDistance:
    case PbSampleType_SampleTypeStrideLength:
    case PbSampleType_SampleTypeStrideCalibration:
    case PbSampleType_SampleTypeForwardAcceleration:
    case PbSampleType_SampleTypeMovingType:
    case PbSampleType_SampleTypeLeftPedalPower:
    case PbSampleType_SampleTypeRightPedalPower:
    case PbSampleType_SampleTypeLeftPedalPowerCalibration:
    case PbSampleType_SampleTypeRightPedalPowerCalibration:
    case PbSampleType_SampleTypeRrInterval:
    case PbSampleType_SampleTypeAccelerationMad:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PbSampleSourceType

GPBEnumDescriptor *PbSampleSourceType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "SampleSourceTypeUndefined\000SampleSourceTy"
        "peOffline\000SampleSourceTypeHeartRate\000Samp"
        "leSourceTypeHeartRateBle\000SampleSourceTyp"
        "eHeartRate5Khz\000SampleSourceTypeHeartRate"
        "Optical\000SampleSourceTypeGps\000SampleSource"
        "TypeStride\000SampleSourceTypeWristMetrics\000"
        "SampleSourceTypeChestMetrics\000SampleSourc"
        "eTypeBikePedal\000SampleSourceTypeBikeWheel"
        "\000SampleSourceTypeBikeCrank\000SampleSourceT"
        "ypeCombinedChestMetricsAndGps\000SampleSour"
        "ceTypeUpperBackMetrics\000SampleSourceTypeC"
        "ombinedUpperBackMetricsAndGps\000";
    static const int32_t values[] = {
        PbSampleSourceType_SampleSourceTypeUndefined,
        PbSampleSourceType_SampleSourceTypeOffline,
        PbSampleSourceType_SampleSourceTypeHeartRate,
        PbSampleSourceType_SampleSourceTypeHeartRateBle,
        PbSampleSourceType_SampleSourceTypeHeartRate5Khz,
        PbSampleSourceType_SampleSourceTypeHeartRateOptical,
        PbSampleSourceType_SampleSourceTypeGps,
        PbSampleSourceType_SampleSourceTypeStride,
        PbSampleSourceType_SampleSourceTypeWristMetrics,
        PbSampleSourceType_SampleSourceTypeChestMetrics,
        PbSampleSourceType_SampleSourceTypeBikePedal,
        PbSampleSourceType_SampleSourceTypeBikeWheel,
        PbSampleSourceType_SampleSourceTypeBikeCrank,
        PbSampleSourceType_SampleSourceTypeCombinedChestMetricsAndGps,
        PbSampleSourceType_SampleSourceTypeUpperBackMetrics,
        PbSampleSourceType_SampleSourceTypeCombinedUpperBackMetricsAndGps,
    };
    static const char *extraTextFormatInfo = "\001\004f\346\344\345\344\201\343\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbSampleSourceType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbSampleSourceType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbSampleSourceType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbSampleSourceType_SampleSourceTypeUndefined:
    case PbSampleSourceType_SampleSourceTypeOffline:
    case PbSampleSourceType_SampleSourceTypeHeartRate:
    case PbSampleSourceType_SampleSourceTypeHeartRateBle:
    case PbSampleSourceType_SampleSourceTypeHeartRate5Khz:
    case PbSampleSourceType_SampleSourceTypeHeartRateOptical:
    case PbSampleSourceType_SampleSourceTypeGps:
    case PbSampleSourceType_SampleSourceTypeStride:
    case PbSampleSourceType_SampleSourceTypeWristMetrics:
    case PbSampleSourceType_SampleSourceTypeChestMetrics:
    case PbSampleSourceType_SampleSourceTypeBikePedal:
    case PbSampleSourceType_SampleSourceTypeBikeWheel:
    case PbSampleSourceType_SampleSourceTypeBikeCrank:
    case PbSampleSourceType_SampleSourceTypeCombinedChestMetricsAndGps:
    case PbSampleSourceType_SampleSourceTypeUpperBackMetrics:
    case PbSampleSourceType_SampleSourceTypeCombinedUpperBackMetricsAndGps:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PbAltitudeSetting

GPBEnumDescriptor *PbAltitudeSetting_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "AltitudeOff\000AltitudeOn\000";
    static const int32_t values[] = {
        PbAltitudeSetting_AltitudeOff,
        PbAltitudeSetting_AltitudeOn,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbAltitudeSetting)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbAltitudeSetting_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbAltitudeSetting_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbAltitudeSetting_AltitudeOff:
    case PbAltitudeSetting_AltitudeOn:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PbGPSSetting

GPBEnumDescriptor *PbGPSSetting_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "GpsOff\000GpsOnNormal\000GpsOnLong\000GpsOn10Hz\000G"
        "psOnMedium\000";
    static const int32_t values[] = {
        PbGPSSetting_GpsOff,
        PbGPSSetting_GpsOnNormal,
        PbGPSSetting_GpsOnLong,
        PbGPSSetting_GpsOn10Hz,
        PbGPSSetting_GpsOnMedium,
    };
    static const char *extraTextFormatInfo = "\001\003c\342\202\342\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbGPSSetting)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbGPSSetting_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbGPSSetting_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbGPSSetting_GpsOff:
    case PbGPSSetting_GpsOnNormal:
    case PbGPSSetting_GpsOnLong:
    case PbGPSSetting_GpsOn10Hz:
    case PbGPSSetting_GpsOnMedium:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PbHeartTouch

GPBEnumDescriptor *PbHeartTouch_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "HeartTouchOff\000HeartTouchActivateBackligh"
        "t\000HeartTouchShowPreviousLap\000HeartTouchSh"
        "owTimeOfDay\000";
    static const int32_t values[] = {
        PbHeartTouch_HeartTouchOff,
        PbHeartTouch_HeartTouchActivateBacklight,
        PbHeartTouch_HeartTouchShowPreviousLap,
        PbHeartTouch_HeartTouchShowTimeOfDay,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbHeartTouch)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbHeartTouch_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbHeartTouch_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbHeartTouch_HeartTouchOff:
    case PbHeartTouch_HeartTouchActivateBacklight:
    case PbHeartTouch_HeartTouchShowPreviousLap:
    case PbHeartTouch_HeartTouchShowTimeOfDay:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PbTapButtonAction

GPBEnumDescriptor *PbTapButtonAction_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "TapButtonOff\000TapButtonTakeLap\000TapButtonC"
        "hangeTrainingView\000TapButtonActivateBackl"
        "ight\000";
    static const int32_t values[] = {
        PbTapButtonAction_TapButtonOff,
        PbTapButtonAction_TapButtonTakeLap,
        PbTapButtonAction_TapButtonChangeTrainingView,
        PbTapButtonAction_TapButtonActivateBacklight,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbTapButtonAction)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbTapButtonAction_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbTapButtonAction_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbTapButtonAction_TapButtonOff:
    case PbTapButtonAction_TapButtonTakeLap:
    case PbTapButtonAction_TapButtonChangeTrainingView:
    case PbTapButtonAction_TapButtonActivateBacklight:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PbHandedness

GPBEnumDescriptor *PbHandedness_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "WuInLeftHand\000WuInRightHand\000WuInNecklace\000";
    static const int32_t values[] = {
        PbHandedness_WuInLeftHand,
        PbHandedness_WuInRightHand,
        PbHandedness_WuInNecklace,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbHandedness)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbHandedness_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbHandedness_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbHandedness_WuInLeftHand:
    case PbHandedness_WuInRightHand:
    case PbHandedness_WuInNecklace:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PbDeviceLocation

GPBEnumDescriptor *PbDeviceLocation_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "DeviceLocationUndefined\000DeviceLocationOt"
        "her\000DeviceLocationWristLeft\000DeviceLocati"
        "onWristRight\000DeviceLocationNecklace\000Devi"
        "ceLocationChest\000DeviceLocationUpperBack\000"
        "DeviceLocationFootLeft\000DeviceLocationFoo"
        "tRight\000DeviceLocationLowerArmLeft\000Device"
        "LocationLowerArmRight\000DeviceLocationUppe"
        "rArmLeft\000DeviceLocationUpperArmRight\000Dev"
        "iceLocationBikeMount\000";
    static const int32_t values[] = {
        PbDeviceLocation_DeviceLocationUndefined,
        PbDeviceLocation_DeviceLocationOther,
        PbDeviceLocation_DeviceLocationWristLeft,
        PbDeviceLocation_DeviceLocationWristRight,
        PbDeviceLocation_DeviceLocationNecklace,
        PbDeviceLocation_DeviceLocationChest,
        PbDeviceLocation_DeviceLocationUpperBack,
        PbDeviceLocation_DeviceLocationFootLeft,
        PbDeviceLocation_DeviceLocationFootRight,
        PbDeviceLocation_DeviceLocationLowerArmLeft,
        PbDeviceLocation_DeviceLocationLowerArmRight,
        PbDeviceLocation_DeviceLocationUpperArmLeft,
        PbDeviceLocation_DeviceLocationUpperArmRight,
        PbDeviceLocation_DeviceLocationBikeMount,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbDeviceLocation)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbDeviceLocation_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbDeviceLocation_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbDeviceLocation_DeviceLocationUndefined:
    case PbDeviceLocation_DeviceLocationOther:
    case PbDeviceLocation_DeviceLocationWristLeft:
    case PbDeviceLocation_DeviceLocationWristRight:
    case PbDeviceLocation_DeviceLocationNecklace:
    case PbDeviceLocation_DeviceLocationChest:
    case PbDeviceLocation_DeviceLocationUpperBack:
    case PbDeviceLocation_DeviceLocationFootLeft:
    case PbDeviceLocation_DeviceLocationFootRight:
    case PbDeviceLocation_DeviceLocationLowerArmLeft:
    case PbDeviceLocation_DeviceLocationLowerArmRight:
    case PbDeviceLocation_DeviceLocationUpperArmLeft:
    case PbDeviceLocation_DeviceLocationUpperArmRight:
    case PbDeviceLocation_DeviceLocationBikeMount:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PbSessionRPE

GPBEnumDescriptor *PbSessionRPE_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "RpeNone\000RpeEasy\000RpeLight\000RpeFairlyBrisk\000"
        "RpeBrisk\000RpeModerate\000RpeFairlyHard\000RpeHa"
        "rd\000RpeExhausting\000RpeExtreme\000";
    static const int32_t values[] = {
        PbSessionRPE_RpeNone,
        PbSessionRPE_RpeEasy,
        PbSessionRPE_RpeLight,
        PbSessionRPE_RpeFairlyBrisk,
        PbSessionRPE_RpeBrisk,
        PbSessionRPE_RpeModerate,
        PbSessionRPE_RpeFairlyHard,
        PbSessionRPE_RpeHard,
        PbSessionRPE_RpeExhausting,
        PbSessionRPE_RpeExtreme,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbSessionRPE)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbSessionRPE_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbSessionRPE_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbSessionRPE_RpeNone:
    case PbSessionRPE_RpeEasy:
    case PbSessionRPE_RpeLight:
    case PbSessionRPE_RpeFairlyBrisk:
    case PbSessionRPE_RpeBrisk:
    case PbSessionRPE_RpeModerate:
    case PbSessionRPE_RpeFairlyHard:
    case PbSessionRPE_RpeHard:
    case PbSessionRPE_RpeExhausting:
    case PbSessionRPE_RpeExtreme:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PbMuscleSoreness

GPBEnumDescriptor *PbMuscleSoreness_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "MsUndefined\000MsNone\000MsSome\000MsMuch\000";
    static const int32_t values[] = {
        PbMuscleSoreness_MsUndefined,
        PbMuscleSoreness_MsNone,
        PbMuscleSoreness_MsSome,
        PbMuscleSoreness_MsMuch,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbMuscleSoreness)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbMuscleSoreness_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbMuscleSoreness_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbMuscleSoreness_MsUndefined:
    case PbMuscleSoreness_MsNone:
    case PbMuscleSoreness_MsSome:
    case PbMuscleSoreness_MsMuch:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PbOverallFatigue

GPBEnumDescriptor *PbOverallFatigue_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "OfUndefined\000OfNormal\000OfALittle\000OfMuch\000";
    static const int32_t values[] = {
        PbOverallFatigue_OfUndefined,
        PbOverallFatigue_OfNormal,
        PbOverallFatigue_OfALittle,
        PbOverallFatigue_OfMuch,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbOverallFatigue)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbOverallFatigue_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbOverallFatigue_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbOverallFatigue_OfUndefined:
    case PbOverallFatigue_OfNormal:
    case PbOverallFatigue_OfALittle:
    case PbOverallFatigue_OfMuch:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PbSleepUserRating

GPBEnumDescriptor *PbSleepUserRating_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "PbSleptUndefined\000PbSleptPoorly\000PbSleptSo"
        "mewhatPoorly\000PbSleptNeitherPoorlyNorWell"
        "\000PbSleptSomewhatWell\000PbSleptWell\000";
    static const int32_t values[] = {
        PbSleepUserRating_PbSleptUndefined,
        PbSleepUserRating_PbSleptPoorly,
        PbSleepUserRating_PbSleptSomewhatPoorly,
        PbSleepUserRating_PbSleptNeitherPoorlyNorWell,
        PbSleepUserRating_PbSleptSomewhatWell,
        PbSleepUserRating_PbSleptWell,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbSleepUserRating)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbSleepUserRating_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbSleepUserRating_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbSleepUserRating_PbSleptUndefined:
    case PbSleepUserRating_PbSleptPoorly:
    case PbSleepUserRating_PbSleptSomewhatPoorly:
    case PbSleepUserRating_PbSleptNeitherPoorlyNorWell:
    case PbSleepUserRating_PbSleptSomewhatWell:
    case PbSleepUserRating_PbSleptWell:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PbRangeOptions

@implementation PbRangeOptions

@dynamic hasMinValue, minValue;
@dynamic hasMaxValue, maxValue;

typedef struct PbRangeOptions__storage_ {
  uint32_t _has_storage_[1];
  int32_t minValue;
  int32_t maxValue;
} PbRangeOptions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "minValue",
        .dataTypeSpecific.className = NULL,
        .number = PbRangeOptions_FieldNumber_MinValue,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbRangeOptions__storage_, minValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "maxValue",
        .dataTypeSpecific.className = NULL,
        .number = PbRangeOptions_FieldNumber_MaxValue,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbRangeOptions__storage_, maxValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbRangeOptions class]
                                     rootClass:[TypesRoot class]
                                          file:TypesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbRangeOptions__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbDate

@implementation PbDate

@dynamic hasYear, year;
@dynamic hasMonth, month;
@dynamic hasDay, day;

typedef struct PbDate__storage_ {
  uint32_t _has_storage_[1];
  uint32_t year;
  uint32_t month;
  uint32_t day;
} PbDate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "year",
        .dataTypeSpecific.className = NULL,
        .number = PbDate_FieldNumber_Year,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbDate__storage_, year),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "month",
        .dataTypeSpecific.className = NULL,
        .number = PbDate_FieldNumber_Month,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbDate__storage_, month),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "day",
        .dataTypeSpecific.className = NULL,
        .number = PbDate_FieldNumber_Day,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PbDate__storage_, day),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbDate class]
                                     rootClass:[TypesRoot class]
                                          file:TypesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbDate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbTime

@implementation PbTime

@dynamic hasHour, hour;
@dynamic hasMinute, minute;
@dynamic hasSeconds, seconds;
@dynamic hasMillis, millis;

typedef struct PbTime__storage_ {
  uint32_t _has_storage_[1];
  uint32_t hour;
  uint32_t minute;
  uint32_t seconds;
  uint32_t millis;
} PbTime__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hour",
        .dataTypeSpecific.className = NULL,
        .number = PbTime_FieldNumber_Hour,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbTime__storage_, hour),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "minute",
        .dataTypeSpecific.className = NULL,
        .number = PbTime_FieldNumber_Minute,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbTime__storage_, minute),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "seconds",
        .dataTypeSpecific.className = NULL,
        .number = PbTime_FieldNumber_Seconds,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PbTime__storage_, seconds),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "millis",
        .dataTypeSpecific.className = NULL,
        .number = PbTime_FieldNumber_Millis,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PbTime__storage_, millis),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbTime class]
                                     rootClass:[TypesRoot class]
                                          file:TypesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbTime__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbSystemDateTime

@implementation PbSystemDateTime

@dynamic hasDate, date;
@dynamic hasTime, time;
@dynamic hasTrusted, trusted;

typedef struct PbSystemDateTime__storage_ {
  uint32_t _has_storage_[1];
  PbDate *date;
  PbTime *time;
} PbSystemDateTime__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "date",
        .dataTypeSpecific.className = GPBStringifySymbol(PbDate),
        .number = PbSystemDateTime_FieldNumber_Date,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbSystemDateTime__storage_, date),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "time",
        .dataTypeSpecific.className = GPBStringifySymbol(PbTime),
        .number = PbSystemDateTime_FieldNumber_Time,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbSystemDateTime__storage_, time),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "trusted",
        .dataTypeSpecific.className = NULL,
        .number = PbSystemDateTime_FieldNumber_Trusted,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbSystemDateTime class]
                                     rootClass:[TypesRoot class]
                                          file:TypesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbSystemDateTime__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbLocalDateTime

@implementation PbLocalDateTime

@dynamic hasDate, date;
@dynamic hasTime, time;
@dynamic hasObsoleteTrusted, obsoleteTrusted;
@dynamic hasTimeZoneOffset, timeZoneOffset;

typedef struct PbLocalDateTime__storage_ {
  uint32_t _has_storage_[1];
  int32_t timeZoneOffset;
  PbDate *date;
  PbTime *time;
} PbLocalDateTime__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "date",
        .dataTypeSpecific.className = GPBStringifySymbol(PbDate),
        .number = PbLocalDateTime_FieldNumber_Date,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbLocalDateTime__storage_, date),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "time",
        .dataTypeSpecific.className = GPBStringifySymbol(PbTime),
        .number = PbLocalDateTime_FieldNumber_Time,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbLocalDateTime__storage_, time),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "obsoleteTrusted",
        .dataTypeSpecific.className = NULL,
        .number = PbLocalDateTime_FieldNumber_ObsoleteTrusted,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "timeZoneOffset",
        .dataTypeSpecific.className = NULL,
        .number = PbLocalDateTime_FieldNumber_TimeZoneOffset,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PbLocalDateTime__storage_, timeZoneOffset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbLocalDateTime class]
                                     rootClass:[TypesRoot class]
                                          file:TypesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbLocalDateTime__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003h\247\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbDuration

@implementation PbDuration

@dynamic hasHours, hours;
@dynamic hasMinutes, minutes;
@dynamic hasSeconds, seconds;
@dynamic hasMillis, millis;

typedef struct PbDuration__storage_ {
  uint32_t _has_storage_[1];
  uint32_t hours;
  uint32_t minutes;
  uint32_t seconds;
  uint32_t millis;
} PbDuration__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hours",
        .dataTypeSpecific.className = NULL,
        .number = PbDuration_FieldNumber_Hours,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbDuration__storage_, hours),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "minutes",
        .dataTypeSpecific.className = NULL,
        .number = PbDuration_FieldNumber_Minutes,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbDuration__storage_, minutes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "seconds",
        .dataTypeSpecific.className = NULL,
        .number = PbDuration_FieldNumber_Seconds,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PbDuration__storage_, seconds),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "millis",
        .dataTypeSpecific.className = NULL,
        .number = PbDuration_FieldNumber_Millis,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PbDuration__storage_, millis),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbDuration class]
                                     rootClass:[TypesRoot class]
                                          file:TypesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbDuration__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbLocation

@implementation PbLocation

@dynamic hasLatitude, latitude;
@dynamic hasLongitude, longitude;
@dynamic hasTimestamp, timestamp;
@dynamic hasFix, fix;
@dynamic hasSatellites, satellites;

typedef struct PbLocation__storage_ {
  uint32_t _has_storage_[1];
  PbLocation_Fix fix;
  uint32_t satellites;
  PbSystemDateTime *timestamp;
  double latitude;
  double longitude;
} PbLocation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "latitude",
        .dataTypeSpecific.className = NULL,
        .number = PbLocation_FieldNumber_Latitude,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbLocation__storage_, latitude),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "longitude",
        .dataTypeSpecific.className = NULL,
        .number = PbLocation_FieldNumber_Longitude,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbLocation__storage_, longitude),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = GPBStringifySymbol(PbSystemDateTime),
        .number = PbLocation_FieldNumber_Timestamp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PbLocation__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fix",
        .dataTypeSpecific.enumDescFunc = PbLocation_Fix_EnumDescriptor,
        .number = PbLocation_FieldNumber_Fix,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PbLocation__storage_, fix),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "satellites",
        .dataTypeSpecific.className = NULL,
        .number = PbLocation_FieldNumber_Satellites,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PbLocation__storage_, satellites),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbLocation class]
                                     rootClass:[TypesRoot class]
                                          file:TypesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbLocation__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum PbLocation_Fix

GPBEnumDescriptor *PbLocation_Fix_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "FixNone\000Fix2D\000Fix3D\000";
    static const int32_t values[] = {
        PbLocation_Fix_FixNone,
        PbLocation_Fix_Fix2D,
        PbLocation_Fix_Fix3D,
    };
    static const char *extraTextFormatInfo = "\002\001c\202\000\002c\202\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbLocation_Fix)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbLocation_Fix_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbLocation_Fix_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbLocation_Fix_FixNone:
    case PbLocation_Fix_Fix2D:
    case PbLocation_Fix_Fix3D:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PbSensorOffline

@implementation PbSensorOffline

@dynamic hasStartIndex, startIndex;
@dynamic hasStopIndex, stopIndex;

typedef struct PbSensorOffline__storage_ {
  uint32_t _has_storage_[1];
  uint32_t startIndex;
  uint32_t stopIndex;
} PbSensorOffline__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startIndex",
        .dataTypeSpecific.className = NULL,
        .number = PbSensorOffline_FieldNumber_StartIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbSensorOffline__storage_, startIndex),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "stopIndex",
        .dataTypeSpecific.className = NULL,
        .number = PbSensorOffline_FieldNumber_StopIndex,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbSensorOffline__storage_, stopIndex),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbSensorOffline class]
                                     rootClass:[TypesRoot class]
                                          file:TypesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbSensorOffline__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbVolume

@implementation PbVolume

@dynamic hasVolume, volume;

typedef struct PbVolume__storage_ {
  uint32_t _has_storage_[1];
  uint32_t volume;
} PbVolume__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "volume",
        .dataTypeSpecific.className = NULL,
        .number = PbVolume_FieldNumber_Volume,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbVolume__storage_, volume),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbVolume class]
                                     rootClass:[TypesRoot class]
                                          file:TypesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbVolume__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbStrideSensorCalibSettings

@implementation PbStrideSensorCalibSettings

@dynamic hasRunningFactor, runningFactor;
@dynamic hasCalibType, calibType;
@dynamic hasRunningFactorSource, runningFactorSource;

typedef struct PbStrideSensorCalibSettings__storage_ {
  uint32_t _has_storage_[1];
  float runningFactor;
  PbStrideSensorCalibSettings_PbStrideCalibType calibType;
  PbStrideSensorCalibSettings_PbRunningFactorSource runningFactorSource;
} PbStrideSensorCalibSettings__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "runningFactor",
        .dataTypeSpecific.className = NULL,
        .number = PbStrideSensorCalibSettings_FieldNumber_RunningFactor,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbStrideSensorCalibSettings__storage_, runningFactor),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "calibType",
        .dataTypeSpecific.enumDescFunc = PbStrideSensorCalibSettings_PbStrideCalibType_EnumDescriptor,
        .number = PbStrideSensorCalibSettings_FieldNumber_CalibType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbStrideSensorCalibSettings__storage_, calibType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "runningFactorSource",
        .dataTypeSpecific.enumDescFunc = PbStrideSensorCalibSettings_PbRunningFactorSource_EnumDescriptor,
        .number = PbStrideSensorCalibSettings_FieldNumber_RunningFactorSource,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PbStrideSensorCalibSettings__storage_, runningFactorSource),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbStrideSensorCalibSettings class]
                                     rootClass:[TypesRoot class]
                                          file:TypesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbStrideSensorCalibSettings__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum PbStrideSensorCalibSettings_PbStrideCalibType

GPBEnumDescriptor *PbStrideSensorCalibSettings_PbStrideCalibType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "StrideCalibManual\000StrideCalibAuto\000";
    static const int32_t values[] = {
        PbStrideSensorCalibSettings_PbStrideCalibType_StrideCalibManual,
        PbStrideSensorCalibSettings_PbStrideCalibType_StrideCalibAuto,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbStrideSensorCalibSettings_PbStrideCalibType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbStrideSensorCalibSettings_PbStrideCalibType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbStrideSensorCalibSettings_PbStrideCalibType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbStrideSensorCalibSettings_PbStrideCalibType_StrideCalibManual:
    case PbStrideSensorCalibSettings_PbStrideCalibType_StrideCalibAuto:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PbStrideSensorCalibSettings_PbRunningFactorSource

GPBEnumDescriptor *PbStrideSensorCalibSettings_PbRunningFactorSource_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "RunningFactorSourceDefault\000RunningFactor"
        "SourceAutoCalibration\000RunningFactorSourc"
        "eManualCalibration\000";
    static const int32_t values[] = {
        PbStrideSensorCalibSettings_PbRunningFactorSource_RunningFactorSourceDefault,
        PbStrideSensorCalibSettings_PbRunningFactorSource_RunningFactorSourceAutoCalibration,
        PbStrideSensorCalibSettings_PbRunningFactorSource_RunningFactorSourceManualCalibration,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbStrideSensorCalibSettings_PbRunningFactorSource)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbStrideSensorCalibSettings_PbRunningFactorSource_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbStrideSensorCalibSettings_PbRunningFactorSource_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbStrideSensorCalibSettings_PbRunningFactorSource_RunningFactorSourceDefault:
    case PbStrideSensorCalibSettings_PbRunningFactorSource_RunningFactorSourceAutoCalibration:
    case PbStrideSensorCalibSettings_PbRunningFactorSource_RunningFactorSourceManualCalibration:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PbWeek

@implementation PbWeek

@dynamic hasWeekNumberIso8601, weekNumberIso8601;
@dynamic hasYear, year;
@dynamic hasTimeZoneOffset, timeZoneOffset;
@dynamic hasWeekStartDay, weekStartDay;

typedef struct PbWeek__storage_ {
  uint32_t _has_storage_[1];
  uint32_t weekNumberIso8601;
  uint32_t year;
  int32_t timeZoneOffset;
  PbStartDayOfWeek weekStartDay;
} PbWeek__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "weekNumberIso8601",
        .core.dataTypeSpecific.className = NULL,
        .core.number = PbWeek_FieldNumber_WeekNumberIso8601,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(PbWeek__storage_, weekNumberIso8601),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "year",
        .core.dataTypeSpecific.className = NULL,
        .core.number = PbWeek_FieldNumber_Year,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(PbWeek__storage_, year),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "timeZoneOffset",
        .core.dataTypeSpecific.className = NULL,
        .core.number = PbWeek_FieldNumber_TimeZoneOffset,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(PbWeek__storage_, timeZoneOffset),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeInt32,
      },
      {
        .defaultValue.valueEnum = PbStartDayOfWeek_Monday,
        .core.name = "weekStartDay",
        .core.dataTypeSpecific.enumDescFunc = PbStartDayOfWeek_EnumDescriptor,
        .core.number = PbWeek_FieldNumber_WeekStartDay,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(PbWeek__storage_, weekStartDay),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbWeek class]
                                     rootClass:[TypesRoot class]
                                          file:TypesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(PbWeek__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\004\246\343\004\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbSampleSource

@implementation PbSampleSource

@dynamic hasSampleSourceType, sampleSourceType;
@dynamic hasStartIndex, startIndex;
@dynamic hasStopIndex, stopIndex;

typedef struct PbSampleSource__storage_ {
  uint32_t _has_storage_[1];
  PbSampleSourceType sampleSourceType;
  uint32_t startIndex;
  uint32_t stopIndex;
} PbSampleSource__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sampleSourceType",
        .dataTypeSpecific.enumDescFunc = PbSampleSourceType_EnumDescriptor,
        .number = PbSampleSource_FieldNumber_SampleSourceType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbSampleSource__storage_, sampleSourceType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "startIndex",
        .dataTypeSpecific.className = NULL,
        .number = PbSampleSource_FieldNumber_StartIndex,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbSampleSource__storage_, startIndex),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "stopIndex",
        .dataTypeSpecific.className = NULL,
        .number = PbSampleSource_FieldNumber_StopIndex,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PbSampleSource__storage_, stopIndex),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbSampleSource class]
                                     rootClass:[TypesRoot class]
                                          file:TypesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbSampleSource__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbSensorCalibrationOffset

@implementation PbSensorCalibrationOffset

@dynamic hasSampleSourceType, sampleSourceType;
@dynamic hasSpeedCalOffset, speedCalOffset;

typedef struct PbSensorCalibrationOffset__storage_ {
  uint32_t _has_storage_[1];
  PbSampleSourceType sampleSourceType;
  float speedCalOffset;
} PbSensorCalibrationOffset__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sampleSourceType",
        .dataTypeSpecific.enumDescFunc = PbSampleSourceType_EnumDescriptor,
        .number = PbSensorCalibrationOffset_FieldNumber_SampleSourceType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbSensorCalibrationOffset__storage_, sampleSourceType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "speedCalOffset",
        .dataTypeSpecific.className = NULL,
        .number = PbSensorCalibrationOffset_FieldNumber_SpeedCalOffset,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbSensorCalibrationOffset__storage_, speedCalOffset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbSensorCalibrationOffset class]
                                     rootClass:[TypesRoot class]
                                          file:TypesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbSensorCalibrationOffset__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbCalibrationSettings

@implementation PbCalibrationSettings

@dynamic hasSampleType, sampleType;
@dynamic hasCalibrationEnabled, calibrationEnabled;
@dynamic hasCalibrationCalculationEnabled, calibrationCalculationEnabled;

typedef struct PbCalibrationSettings__storage_ {
  uint32_t _has_storage_[1];
  PbSampleType sampleType;
} PbCalibrationSettings__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sampleType",
        .dataTypeSpecific.enumDescFunc = PbSampleType_EnumDescriptor,
        .number = PbCalibrationSettings_FieldNumber_SampleType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbCalibrationSettings__storage_, sampleType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "calibrationEnabled",
        .dataTypeSpecific.className = NULL,
        .number = PbCalibrationSettings_FieldNumber_CalibrationEnabled,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "calibrationCalculationEnabled",
        .dataTypeSpecific.className = NULL,
        .number = PbCalibrationSettings_FieldNumber_CalibrationCalculationEnabled,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbCalibrationSettings class]
                                     rootClass:[TypesRoot class]
                                          file:TypesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbCalibrationSettings__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbAccelerationMetrics

@implementation PbAccelerationMetrics

@dynamic hasSampleSourceType, sampleSourceType;
@dynamic calibrationSettingsArray, calibrationSettingsArray_Count;

typedef struct PbAccelerationMetrics__storage_ {
  uint32_t _has_storage_[1];
  PbSampleSourceType sampleSourceType;
  NSMutableArray *calibrationSettingsArray;
} PbAccelerationMetrics__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sampleSourceType",
        .dataTypeSpecific.enumDescFunc = PbSampleSourceType_EnumDescriptor,
        .number = PbAccelerationMetrics_FieldNumber_SampleSourceType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbAccelerationMetrics__storage_, sampleSourceType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "calibrationSettingsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PbCalibrationSettings),
        .number = PbAccelerationMetrics_FieldNumber_CalibrationSettingsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PbAccelerationMetrics__storage_, calibrationSettingsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbAccelerationMetrics class]
                                     rootClass:[TypesRoot class]
                                          file:TypesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbAccelerationMetrics__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbAutoPause

@implementation PbAutoPause

@dynamic hasTrigger, trigger;
@dynamic hasSpeedThreshold, speedThreshold;

typedef struct PbAutoPause__storage_ {
  uint32_t _has_storage_[1];
  PbAutoPause_PbAutoPauseTrigger trigger;
  float speedThreshold;
} PbAutoPause__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "trigger",
        .dataTypeSpecific.enumDescFunc = PbAutoPause_PbAutoPauseTrigger_EnumDescriptor,
        .number = PbAutoPause_FieldNumber_Trigger,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbAutoPause__storage_, trigger),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "speedThreshold",
        .dataTypeSpecific.className = NULL,
        .number = PbAutoPause_FieldNumber_SpeedThreshold,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbAutoPause__storage_, speedThreshold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbAutoPause class]
                                     rootClass:[TypesRoot class]
                                          file:TypesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbAutoPause__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum PbAutoPause_PbAutoPauseTrigger

GPBEnumDescriptor *PbAutoPause_PbAutoPauseTrigger_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "AutoPauseOff\000AutoPauseTriggerSpeed\000";
    static const int32_t values[] = {
        PbAutoPause_PbAutoPauseTrigger_AutoPauseOff,
        PbAutoPause_PbAutoPauseTrigger_AutoPauseTriggerSpeed,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbAutoPause_PbAutoPauseTrigger)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbAutoPause_PbAutoPauseTrigger_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbAutoPause_PbAutoPauseTrigger_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbAutoPause_PbAutoPauseTrigger_AutoPauseOff:
    case PbAutoPause_PbAutoPauseTrigger_AutoPauseTriggerSpeed:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PbAutoLapSettings

@implementation PbAutoLapSettings

@dynamic hasAutomaticLap, automaticLap;
@dynamic hasAutomaticLapDistance, automaticLapDistance;
@dynamic hasAutomaticLapDuration, automaticLapDuration;

typedef struct PbAutoLapSettings__storage_ {
  uint32_t _has_storage_[1];
  PbAutoLapSettings_PbAutomaticLap automaticLap;
  float automaticLapDistance;
  PbDuration *automaticLapDuration;
} PbAutoLapSettings__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = PbAutoLapSettings_PbAutomaticLap_AutomaticLapOff,
        .core.name = "automaticLap",
        .core.dataTypeSpecific.enumDescFunc = PbAutoLapSettings_PbAutomaticLap_EnumDescriptor,
        .core.number = PbAutoLapSettings_FieldNumber_AutomaticLap,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(PbAutoLapSettings__storage_, automaticLap),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueFloat = 0,
        .core.name = "automaticLapDistance",
        .core.dataTypeSpecific.className = NULL,
        .core.number = PbAutoLapSettings_FieldNumber_AutomaticLapDistance,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(PbAutoLapSettings__storage_, automaticLapDistance),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeFloat,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "automaticLapDuration",
        .core.dataTypeSpecific.className = GPBStringifySymbol(PbDuration),
        .core.number = PbAutoLapSettings_FieldNumber_AutomaticLapDuration,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(PbAutoLapSettings__storage_, automaticLapDuration),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbAutoLapSettings class]
                                     rootClass:[TypesRoot class]
                                          file:TypesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(PbAutoLapSettings__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum PbAutoLapSettings_PbAutomaticLap

GPBEnumDescriptor *PbAutoLapSettings_PbAutomaticLap_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "AutomaticLapOff\000AutomaticLapDistance\000Aut"
        "omaticLapDuration\000AutomaticLapLocation\000";
    static const int32_t values[] = {
        PbAutoLapSettings_PbAutomaticLap_AutomaticLapOff,
        PbAutoLapSettings_PbAutomaticLap_AutomaticLapDistance,
        PbAutoLapSettings_PbAutomaticLap_AutomaticLapDuration,
        PbAutoLapSettings_PbAutomaticLap_AutomaticLapLocation,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbAutoLapSettings_PbAutomaticLap)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbAutoLapSettings_PbAutomaticLap_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbAutoLapSettings_PbAutomaticLap_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbAutoLapSettings_PbAutomaticLap_AutomaticLapOff:
    case PbAutoLapSettings_PbAutomaticLap_AutomaticLapDistance:
    case PbAutoLapSettings_PbAutomaticLap_AutomaticLapDuration:
    case PbAutoLapSettings_PbAutomaticLap_AutomaticLapLocation:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PbCardioLoad

@implementation PbCardioLoad

@dynamic hasActivityLoad, activityLoad;
@dynamic hasExerciseLoad, exerciseLoad;

typedef struct PbCardioLoad__storage_ {
  uint32_t _has_storage_[1];
  float activityLoad;
  float exerciseLoad;
} PbCardioLoad__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "activityLoad",
        .dataTypeSpecific.className = NULL,
        .number = PbCardioLoad_FieldNumber_ActivityLoad,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbCardioLoad__storage_, activityLoad),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "exerciseLoad",
        .dataTypeSpecific.className = NULL,
        .number = PbCardioLoad_FieldNumber_ExerciseLoad,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbCardioLoad__storage_, exerciseLoad),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbCardioLoad class]
                                     rootClass:[TypesRoot class]
                                          file:TypesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbCardioLoad__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbPerceivedLoad

@implementation PbPerceivedLoad

@dynamic hasSessionRpe, sessionRpe;
@dynamic hasDuration, duration;

typedef struct PbPerceivedLoad__storage_ {
  uint32_t _has_storage_[1];
  PbSessionRPE sessionRpe;
  uint32_t duration;
} PbPerceivedLoad__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = PbSessionRPE_RpeModerate,
        .core.name = "sessionRpe",
        .core.dataTypeSpecific.enumDescFunc = PbSessionRPE_EnumDescriptor,
        .core.number = PbPerceivedLoad_FieldNumber_SessionRpe,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(PbPerceivedLoad__storage_, sessionRpe),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "duration",
        .core.dataTypeSpecific.className = NULL,
        .core.number = PbPerceivedLoad_FieldNumber_Duration,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(PbPerceivedLoad__storage_, duration),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbPerceivedLoad class]
                                     rootClass:[TypesRoot class]
                                          file:TypesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(PbPerceivedLoad__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
