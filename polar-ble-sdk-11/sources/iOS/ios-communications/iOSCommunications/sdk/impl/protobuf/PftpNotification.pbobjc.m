// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pftp_notification.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "PftpNotification.pbobjc.h"
 #import "Types.pbobjc.h"
 #import "Nanopb.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - PftpNotificationRoot

@implementation PftpNotificationRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    registry = [[GPBExtensionRegistry alloc] init];
    // Merge in the imports (direct or indirect) that defined extensions.
    [registry addExtensions:[TypesRoot extensionRegistry]];
    [registry addExtensions:[NanopbRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - PftpNotificationRoot_FileDescriptor

static GPBFileDescriptor *PftpNotificationRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"protocol"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - Enum PbPFtpDevToHostNotification

GPBEnumDescriptor *PbPFtpDevToHostNotification_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "FilesystemModified\000InternalTestEvent\000Idl"
        "ing\000BatteryStatus\000InactivityAlert\000Traini"
        "ngSessionStatus\000SyncRequired\000AutosyncSta"
        "tus\000PnsDhNotificationResponse\000PnsSetting"
        "s\000StartGpsMeasurement\000StopGpsMeasurement"
        "\000KeepBackgroundAlive\000PolarShellDhData\000";
    static const int32_t values[] = {
        PbPFtpDevToHostNotification_FilesystemModified,
        PbPFtpDevToHostNotification_InternalTestEvent,
        PbPFtpDevToHostNotification_Idling,
        PbPFtpDevToHostNotification_BatteryStatus,
        PbPFtpDevToHostNotification_InactivityAlert,
        PbPFtpDevToHostNotification_TrainingSessionStatus,
        PbPFtpDevToHostNotification_SyncRequired,
        PbPFtpDevToHostNotification_AutosyncStatus,
        PbPFtpDevToHostNotification_PnsDhNotificationResponse,
        PbPFtpDevToHostNotification_PnsSettings,
        PbPFtpDevToHostNotification_StartGpsMeasurement,
        PbPFtpDevToHostNotification_StopGpsMeasurement,
        PbPFtpDevToHostNotification_KeepBackgroundAlive,
        PbPFtpDevToHostNotification_PolarShellDhData,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbPFtpDevToHostNotification)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbPFtpDevToHostNotification_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbPFtpDevToHostNotification_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbPFtpDevToHostNotification_FilesystemModified:
    case PbPFtpDevToHostNotification_InternalTestEvent:
    case PbPFtpDevToHostNotification_Idling:
    case PbPFtpDevToHostNotification_BatteryStatus:
    case PbPFtpDevToHostNotification_InactivityAlert:
    case PbPFtpDevToHostNotification_TrainingSessionStatus:
    case PbPFtpDevToHostNotification_SyncRequired:
    case PbPFtpDevToHostNotification_AutosyncStatus:
    case PbPFtpDevToHostNotification_PnsDhNotificationResponse:
    case PbPFtpDevToHostNotification_PnsSettings:
    case PbPFtpDevToHostNotification_StartGpsMeasurement:
    case PbPFtpDevToHostNotification_StopGpsMeasurement:
    case PbPFtpDevToHostNotification_KeepBackgroundAlive:
    case PbPFtpDevToHostNotification_PolarShellDhData:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Action

GPBEnumDescriptor *Action_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Created\000Updated\000Removed\000";
    static const int32_t values[] = {
        Action_Created,
        Action_Updated,
        Action_Removed,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Action)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Action_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Action_IsValidValue(int32_t value__) {
  switch (value__) {
    case Action_Created:
    case Action_Updated:
    case Action_Removed:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PbPftpPnsDHAttributeType

GPBEnumDescriptor *PbPftpPnsDHAttributeType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "UnknownAction\000PositiveAction\000NegativeAct"
        "ion\000ClearAction\000";
    static const int32_t values[] = {
        PbPftpPnsDHAttributeType_UnknownAction,
        PbPftpPnsDHAttributeType_PositiveAction,
        PbPftpPnsDHAttributeType_NegativeAction,
        PbPftpPnsDHAttributeType_ClearAction,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbPftpPnsDHAttributeType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbPftpPnsDHAttributeType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbPftpPnsDHAttributeType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbPftpPnsDHAttributeType_UnknownAction:
    case PbPftpPnsDHAttributeType_PositiveAction:
    case PbPftpPnsDHAttributeType_NegativeAction:
    case PbPftpPnsDHAttributeType_ClearAction:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PbPFtpHostToDevNotification

GPBEnumDescriptor *PbPFtpHostToDevNotification_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "StartSync\000StopSync\000Reset\000LockProductionD"
        "ata\000TerminateSync\000KeepAlive\000StartAutosyn"
        "c\000PnsHdNotification\000InitializeSession\000Te"
        "rminateSession\000SimulateButtonPress\000Simul"
        "ateTouchScreen\000RequestSync\000FirmwareUpdat"
        "eAvailable\000GpsData\000GpsLost\000GpsNoPermissi"
        "on\000PolarShellHdData\000";
    static const int32_t values[] = {
        PbPFtpHostToDevNotification_StartSync,
        PbPFtpHostToDevNotification_StopSync,
        PbPFtpHostToDevNotification_Reset,
        PbPFtpHostToDevNotification_LockProductionData,
        PbPFtpHostToDevNotification_TerminateSync,
        PbPFtpHostToDevNotification_KeepAlive,
        PbPFtpHostToDevNotification_StartAutosync,
        PbPFtpHostToDevNotification_PnsHdNotification,
        PbPFtpHostToDevNotification_InitializeSession,
        PbPFtpHostToDevNotification_TerminateSession,
        PbPFtpHostToDevNotification_SimulateButtonPress,
        PbPFtpHostToDevNotification_SimulateTouchScreen,
        PbPFtpHostToDevNotification_RequestSync,
        PbPFtpHostToDevNotification_FirmwareUpdateAvailable,
        PbPFtpHostToDevNotification_GpsData,
        PbPFtpHostToDevNotification_GpsLost,
        PbPFtpHostToDevNotification_GpsNoPermission,
        PbPFtpHostToDevNotification_PolarShellHdData,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbPFtpHostToDevNotification)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbPFtpHostToDevNotification_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbPFtpHostToDevNotification_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbPFtpHostToDevNotification_StartSync:
    case PbPFtpHostToDevNotification_StopSync:
    case PbPFtpHostToDevNotification_Reset:
    case PbPFtpHostToDevNotification_LockProductionData:
    case PbPFtpHostToDevNotification_TerminateSync:
    case PbPFtpHostToDevNotification_KeepAlive:
    case PbPFtpHostToDevNotification_StartAutosync:
    case PbPFtpHostToDevNotification_PnsHdNotification:
    case PbPFtpHostToDevNotification_InitializeSession:
    case PbPFtpHostToDevNotification_TerminateSession:
    case PbPFtpHostToDevNotification_SimulateButtonPress:
    case PbPFtpHostToDevNotification_SimulateTouchScreen:
    case PbPFtpHostToDevNotification_RequestSync:
    case PbPFtpHostToDevNotification_FirmwareUpdateAvailable:
    case PbPFtpHostToDevNotification_GpsData:
    case PbPFtpHostToDevNotification_GpsLost:
    case PbPFtpHostToDevNotification_GpsNoPermission:
    case PbPFtpHostToDevNotification_PolarShellHdData:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PbPftpPnsHDCategoryID

GPBEnumDescriptor *PbPftpPnsHDCategoryID_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "CategoryIdOther\000CategoryIdPolar\000Category"
        "IdIncomingcall\000CategoryIdMissedcall\000Cate"
        "goryIdVoicemail\000CategoryIdSocial\000Categor"
        "yIdSchedule\000CategoryIdEmail\000CategoryIdNe"
        "ws\000CategoryIdHealthandfitness\000CategoryId"
        "Businessandfinance\000CategoryIdLocation\000Ca"
        "tegoryIdEntertainment\000CategoryIdAlarm\000Ca"
        "tegoryIdPromo\000CategoryIdRecommendation\000C"
        "ategoryIdStatus\000CategoryIdTransport\000";
    static const int32_t values[] = {
        PbPftpPnsHDCategoryID_CategoryIdOther,
        PbPftpPnsHDCategoryID_CategoryIdPolar,
        PbPftpPnsHDCategoryID_CategoryIdIncomingcall,
        PbPftpPnsHDCategoryID_CategoryIdMissedcall,
        PbPftpPnsHDCategoryID_CategoryIdVoicemail,
        PbPftpPnsHDCategoryID_CategoryIdSocial,
        PbPftpPnsHDCategoryID_CategoryIdSchedule,
        PbPftpPnsHDCategoryID_CategoryIdEmail,
        PbPftpPnsHDCategoryID_CategoryIdNews,
        PbPftpPnsHDCategoryID_CategoryIdHealthandfitness,
        PbPftpPnsHDCategoryID_CategoryIdBusinessandfinance,
        PbPftpPnsHDCategoryID_CategoryIdLocation,
        PbPftpPnsHDCategoryID_CategoryIdEntertainment,
        PbPftpPnsHDCategoryID_CategoryIdAlarm,
        PbPftpPnsHDCategoryID_CategoryIdPromo,
        PbPftpPnsHDCategoryID_CategoryIdRecommendation,
        PbPftpPnsHDCategoryID_CategoryIdStatus,
        PbPftpPnsHDCategoryID_CategoryIdTransport,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbPftpPnsHDCategoryID)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbPftpPnsHDCategoryID_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbPftpPnsHDCategoryID_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbPftpPnsHDCategoryID_CategoryIdOther:
    case PbPftpPnsHDCategoryID_CategoryIdPolar:
    case PbPftpPnsHDCategoryID_CategoryIdIncomingcall:
    case PbPftpPnsHDCategoryID_CategoryIdMissedcall:
    case PbPftpPnsHDCategoryID_CategoryIdVoicemail:
    case PbPftpPnsHDCategoryID_CategoryIdSocial:
    case PbPftpPnsHDCategoryID_CategoryIdSchedule:
    case PbPftpPnsHDCategoryID_CategoryIdEmail:
    case PbPftpPnsHDCategoryID_CategoryIdNews:
    case PbPftpPnsHDCategoryID_CategoryIdHealthandfitness:
    case PbPftpPnsHDCategoryID_CategoryIdBusinessandfinance:
    case PbPftpPnsHDCategoryID_CategoryIdLocation:
    case PbPftpPnsHDCategoryID_CategoryIdEntertainment:
    case PbPftpPnsHDCategoryID_CategoryIdAlarm:
    case PbPftpPnsHDCategoryID_CategoryIdPromo:
    case PbPftpPnsHDCategoryID_CategoryIdRecommendation:
    case PbPftpPnsHDCategoryID_CategoryIdStatus:
    case PbPftpPnsHDCategoryID_CategoryIdTransport:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PbPftpPnsHDAttributeType

GPBEnumDescriptor *PbPftpPnsHDAttributeType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Title\000Subtitle\000Message\000PositiveActionLab"
        "el\000NegativeActionLabel\000ApplicationName\000C"
        "learActionLabel\000";
    static const int32_t values[] = {
        PbPftpPnsHDAttributeType_Title,
        PbPftpPnsHDAttributeType_Subtitle,
        PbPftpPnsHDAttributeType_Message,
        PbPftpPnsHDAttributeType_PositiveActionLabel,
        PbPftpPnsHDAttributeType_NegativeActionLabel,
        PbPftpPnsHDAttributeType_ApplicationName,
        PbPftpPnsHDAttributeType_ClearActionLabel,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbPftpPnsHDAttributeType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbPftpPnsHDAttributeType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbPftpPnsHDAttributeType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbPftpPnsHDAttributeType_Title:
    case PbPftpPnsHDAttributeType_Subtitle:
    case PbPftpPnsHDAttributeType_Message:
    case PbPftpPnsHDAttributeType_PositiveActionLabel:
    case PbPftpPnsHDAttributeType_NegativeActionLabel:
    case PbPftpPnsHDAttributeType_ApplicationName:
    case PbPftpPnsHDAttributeType_ClearActionLabel:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PbPFtpFilesystemModifiedParams

@implementation PbPFtpFilesystemModifiedParams

@dynamic hasAction, action;
@dynamic hasPath, path;

typedef struct PbPFtpFilesystemModifiedParams__storage_ {
  uint32_t _has_storage_[1];
  Action action;
  NSString *path;
} PbPFtpFilesystemModifiedParams__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "action",
        .dataTypeSpecific.enumDescFunc = Action_EnumDescriptor,
        .number = PbPFtpFilesystemModifiedParams_FieldNumber_Action,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbPFtpFilesystemModifiedParams__storage_, action),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "path",
        .dataTypeSpecific.className = NULL,
        .number = PbPFtpFilesystemModifiedParams_FieldNumber_Path,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbPFtpFilesystemModifiedParams__storage_, path),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbPFtpFilesystemModifiedParams class]
                                     rootClass:[PftpNotificationRoot class]
                                          file:PftpNotificationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbPFtpFilesystemModifiedParams__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbPFtpInactivityAlert

@implementation PbPFtpInactivityAlert

@dynamic hasCountdown, countdown;

typedef struct PbPFtpInactivityAlert__storage_ {
  uint32_t _has_storage_[1];
  uint32_t countdown;
} PbPFtpInactivityAlert__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "countdown",
        .dataTypeSpecific.className = NULL,
        .number = PbPFtpInactivityAlert_FieldNumber_Countdown,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbPFtpInactivityAlert__storage_, countdown),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbPFtpInactivityAlert class]
                                     rootClass:[PftpNotificationRoot class]
                                          file:PftpNotificationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbPFtpInactivityAlert__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbPFtpTrainingSessionStatus

@implementation PbPFtpTrainingSessionStatus

@dynamic hasInprogress, inprogress;

typedef struct PbPFtpTrainingSessionStatus__storage_ {
  uint32_t _has_storage_[1];
} PbPFtpTrainingSessionStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "inprogress",
        .dataTypeSpecific.className = NULL,
        .number = PbPFtpTrainingSessionStatus_FieldNumber_Inprogress,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbPFtpTrainingSessionStatus class]
                                     rootClass:[PftpNotificationRoot class]
                                          file:PftpNotificationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbPFtpTrainingSessionStatus__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbPFtpAutoSyncStatusParams

@implementation PbPFtpAutoSyncStatusParams

@dynamic hasSucceeded, succeeded;
@dynamic hasDescription_p, description_p;

typedef struct PbPFtpAutoSyncStatusParams__storage_ {
  uint32_t _has_storage_[1];
  NSString *description_p;
} PbPFtpAutoSyncStatusParams__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "succeeded",
        .dataTypeSpecific.className = NULL,
        .number = PbPFtpAutoSyncStatusParams_FieldNumber_Succeeded,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = PbPFtpAutoSyncStatusParams_FieldNumber_Description_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PbPFtpAutoSyncStatusParams__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbPFtpAutoSyncStatusParams class]
                                     rootClass:[PftpNotificationRoot class]
                                          file:PftpNotificationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbPFtpAutoSyncStatusParams__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbPFtpPolarShellMessageParams

@implementation PbPFtpPolarShellMessageParams

@dynamic hasPolarShellMsgId, polarShellMsgId;
@dynamic hasData_p, data_p;

typedef struct PbPFtpPolarShellMessageParams__storage_ {
  uint32_t _has_storage_[1];
  uint32_t polarShellMsgId;
  NSString *data_p;
} PbPFtpPolarShellMessageParams__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "polarShellMsgId",
        .dataTypeSpecific.className = NULL,
        .number = PbPFtpPolarShellMessageParams_FieldNumber_PolarShellMsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbPFtpPolarShellMessageParams__storage_, polarShellMsgId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = PbPFtpPolarShellMessageParams_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbPFtpPolarShellMessageParams__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbPFtpPolarShellMessageParams class]
                                     rootClass:[PftpNotificationRoot class]
                                          file:PftpNotificationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbPFtpPolarShellMessageParams__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\017\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbPftpPnsDHAttribute

@implementation PbPftpPnsDHAttribute

@dynamic hasType, type;

typedef struct PbPftpPnsDHAttribute__storage_ {
  uint32_t _has_storage_[1];
  PbPftpPnsDHAttributeType type;
} PbPftpPnsDHAttribute__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = PbPftpPnsDHAttributeType_UnknownAction,
        .core.name = "type",
        .core.dataTypeSpecific.enumDescFunc = PbPftpPnsDHAttributeType_EnumDescriptor,
        .core.number = PbPftpPnsDHAttribute_FieldNumber_Type,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(PbPftpPnsDHAttribute__storage_, type),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbPftpPnsDHAttribute class]
                                     rootClass:[PftpNotificationRoot class]
                                          file:PftpNotificationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(PbPftpPnsDHAttribute__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbPftpPnsDHNotificationResponse

@implementation PbPftpPnsDHNotificationResponse

@dynamic hasNotificationId, notificationId;
@dynamic attributesArray, attributesArray_Count;

typedef struct PbPftpPnsDHNotificationResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t notificationId;
  NSMutableArray *attributesArray;
} PbPftpPnsDHNotificationResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "notificationId",
        .dataTypeSpecific.className = NULL,
        .number = PbPftpPnsDHNotificationResponse_FieldNumber_NotificationId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbPftpPnsDHNotificationResponse__storage_, notificationId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "attributesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PbPftpPnsDHAttribute),
        .number = PbPftpPnsDHNotificationResponse_FieldNumber_AttributesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PbPftpPnsDHNotificationResponse__storage_, attributesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbPftpPnsDHNotificationResponse class]
                                     rootClass:[PftpNotificationRoot class]
                                          file:PftpNotificationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbPftpPnsDHNotificationResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbPftpPnsState

@implementation PbPftpPnsState

@dynamic hasNotificationsEnabled, notificationsEnabled;
@dynamic hasPreviewEnabled, previewEnabled;

typedef struct PbPftpPnsState__storage_ {
  uint32_t _has_storage_[1];
} PbPftpPnsState__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "notificationsEnabled",
        .dataTypeSpecific.className = NULL,
        .number = PbPftpPnsState_FieldNumber_NotificationsEnabled,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "previewEnabled",
        .dataTypeSpecific.className = NULL,
        .number = PbPftpPnsState_FieldNumber_PreviewEnabled,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbPftpPnsState class]
                                     rootClass:[PftpNotificationRoot class]
                                          file:PftpNotificationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbPftpPnsState__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbPftpStartGPSMeasurement

@implementation PbPftpStartGPSMeasurement

@dynamic hasMinimumInterval, minimumInterval;
@dynamic hasAccuracy, accuracy;
@dynamic hasLatitude, latitude;
@dynamic hasLongitude, longitude;

typedef struct PbPftpStartGPSMeasurement__storage_ {
  uint32_t _has_storage_[1];
  uint32_t minimumInterval;
  uint32_t accuracy;
  double latitude;
  double longitude;
} PbPftpStartGPSMeasurement__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueUInt32 = 1000U,
        .core.name = "minimumInterval",
        .core.dataTypeSpecific.className = NULL,
        .core.number = PbPftpStartGPSMeasurement_FieldNumber_MinimumInterval,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(PbPftpStartGPSMeasurement__storage_, minimumInterval),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 2U,
        .core.name = "accuracy",
        .core.dataTypeSpecific.className = NULL,
        .core.number = PbPftpStartGPSMeasurement_FieldNumber_Accuracy,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(PbPftpStartGPSMeasurement__storage_, accuracy),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "latitude",
        .core.dataTypeSpecific.className = NULL,
        .core.number = PbPftpStartGPSMeasurement_FieldNumber_Latitude,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(PbPftpStartGPSMeasurement__storage_, latitude),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
      {
        .defaultValue.valueDouble = 0,
        .core.name = "longitude",
        .core.dataTypeSpecific.className = NULL,
        .core.number = PbPftpStartGPSMeasurement_FieldNumber_Longitude,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(PbPftpStartGPSMeasurement__storage_, longitude),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbPftpStartGPSMeasurement class]
                                     rootClass:[PftpNotificationRoot class]
                                          file:PftpNotificationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(PbPftpStartGPSMeasurement__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbInitializeSessionParams

@implementation PbInitializeSessionParams

@dynamic hasUsesAttributeLevelResponse, usesAttributeLevelResponse;

typedef struct PbInitializeSessionParams__storage_ {
  uint32_t _has_storage_[1];
} PbInitializeSessionParams__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "usesAttributeLevelResponse",
        .dataTypeSpecific.className = NULL,
        .number = PbInitializeSessionParams_FieldNumber_UsesAttributeLevelResponse,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbInitializeSessionParams class]
                                     rootClass:[PftpNotificationRoot class]
                                          file:PftpNotificationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbInitializeSessionParams__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbFirmwareUpdateAvailableParams

@implementation PbFirmwareUpdateAvailableParams

@dynamic hasMandatory, mandatory;

typedef struct PbFirmwareUpdateAvailableParams__storage_ {
  uint32_t _has_storage_[1];
} PbFirmwareUpdateAvailableParams__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mandatory",
        .dataTypeSpecific.className = NULL,
        .number = PbFirmwareUpdateAvailableParams_FieldNumber_Mandatory,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbFirmwareUpdateAvailableParams class]
                                     rootClass:[PftpNotificationRoot class]
                                          file:PftpNotificationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbFirmwareUpdateAvailableParams__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbPFtpSimulateButtonPressParams

@implementation PbPFtpSimulateButtonPressParams

@dynamic hasButton, button;
@dynamic hasState, state;

typedef struct PbPFtpSimulateButtonPressParams__storage_ {
  uint32_t _has_storage_[1];
  Buttons button;
  ButtonState state;
} PbPFtpSimulateButtonPressParams__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "button",
        .dataTypeSpecific.enumDescFunc = Buttons_EnumDescriptor,
        .number = PbPFtpSimulateButtonPressParams_FieldNumber_Button,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbPFtpSimulateButtonPressParams__storage_, button),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "state",
        .dataTypeSpecific.enumDescFunc = ButtonState_EnumDescriptor,
        .number = PbPFtpSimulateButtonPressParams_FieldNumber_State,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbPFtpSimulateButtonPressParams__storage_, state),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbPFtpSimulateButtonPressParams class]
                                     rootClass:[PftpNotificationRoot class]
                                          file:PftpNotificationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbPFtpSimulateButtonPressParams__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbPFtpTouchPosition

@implementation PbPFtpTouchPosition

@dynamic hasPos, pos;
@dynamic hasMaxPos, maxPos;

typedef struct PbPFtpTouchPosition__storage_ {
  uint32_t _has_storage_[1];
  uint32_t pos;
  uint32_t maxPos;
} PbPFtpTouchPosition__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pos",
        .dataTypeSpecific.className = NULL,
        .number = PbPFtpTouchPosition_FieldNumber_Pos,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbPFtpTouchPosition__storage_, pos),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "maxPos",
        .dataTypeSpecific.className = NULL,
        .number = PbPFtpTouchPosition_FieldNumber_MaxPos,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbPFtpTouchPosition__storage_, maxPos),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbPFtpTouchPosition class]
                                     rootClass:[PftpNotificationRoot class]
                                          file:PftpNotificationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbPFtpTouchPosition__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbPFtpSimulateTouchScreenParams

@implementation PbPFtpSimulateTouchScreenParams

@dynamic hasState, state;
@dynamic hasXPos, xPos;
@dynamic hasYPos, yPos;

typedef struct PbPFtpSimulateTouchScreenParams__storage_ {
  uint32_t _has_storage_[1];
  PbPFtpSimulateTouchScreenParams_PbPFtpTouchState state;
  PbPFtpTouchPosition *xPos;
  PbPFtpTouchPosition *yPos;
} PbPFtpSimulateTouchScreenParams__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "state",
        .dataTypeSpecific.enumDescFunc = PbPFtpSimulateTouchScreenParams_PbPFtpTouchState_EnumDescriptor,
        .number = PbPFtpSimulateTouchScreenParams_FieldNumber_State,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbPFtpSimulateTouchScreenParams__storage_, state),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "xPos",
        .dataTypeSpecific.className = GPBStringifySymbol(PbPFtpTouchPosition),
        .number = PbPFtpSimulateTouchScreenParams_FieldNumber_XPos,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbPFtpSimulateTouchScreenParams__storage_, xPos),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "yPos",
        .dataTypeSpecific.className = GPBStringifySymbol(PbPFtpTouchPosition),
        .number = PbPFtpSimulateTouchScreenParams_FieldNumber_YPos,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PbPFtpSimulateTouchScreenParams__storage_, yPos),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbPFtpSimulateTouchScreenParams class]
                                     rootClass:[PftpNotificationRoot class]
                                          file:PftpNotificationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbPFtpSimulateTouchScreenParams__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum PbPFtpSimulateTouchScreenParams_PbPFtpTouchState

GPBEnumDescriptor *PbPFtpSimulateTouchScreenParams_PbPFtpTouchState_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "TouchStateStart\000TouchStatePosition\000Touch"
        "StateEnd\000";
    static const int32_t values[] = {
        PbPFtpSimulateTouchScreenParams_PbPFtpTouchState_TouchStateStart,
        PbPFtpSimulateTouchScreenParams_PbPFtpTouchState_TouchStatePosition,
        PbPFtpSimulateTouchScreenParams_PbPFtpTouchState_TouchStateEnd,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PbPFtpSimulateTouchScreenParams_PbPFtpTouchState)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PbPFtpSimulateTouchScreenParams_PbPFtpTouchState_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PbPFtpSimulateTouchScreenParams_PbPFtpTouchState_IsValidValue(int32_t value__) {
  switch (value__) {
    case PbPFtpSimulateTouchScreenParams_PbPFtpTouchState_TouchStateStart:
    case PbPFtpSimulateTouchScreenParams_PbPFtpTouchState_TouchStatePosition:
    case PbPFtpSimulateTouchScreenParams_PbPFtpTouchState_TouchStateEnd:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PbPFtpStopSyncParams

@implementation PbPFtpStopSyncParams

@dynamic hasCompleted, completed;
@dynamic hasDescription_p, description_p;

typedef struct PbPFtpStopSyncParams__storage_ {
  uint32_t _has_storage_[1];
  NSString *description_p;
} PbPFtpStopSyncParams__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "completed",
        .dataTypeSpecific.className = NULL,
        .number = PbPFtpStopSyncParams_FieldNumber_Completed,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = PbPFtpStopSyncParams_FieldNumber_Description_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PbPFtpStopSyncParams__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbPFtpStopSyncParams class]
                                     rootClass:[PftpNotificationRoot class]
                                          file:PftpNotificationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbPFtpStopSyncParams__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbPFtpFactoryResetParams

@implementation PbPFtpFactoryResetParams

@dynamic hasSleep, sleep;
@dynamic hasDoFactoryDefaults, doFactoryDefaults;
@dynamic hasOtaFwupdate, otaFwupdate;

typedef struct PbPFtpFactoryResetParams__storage_ {
  uint32_t _has_storage_[1];
} PbPFtpFactoryResetParams__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueBool = NO,
        .core.name = "sleep",
        .core.dataTypeSpecific.className = NULL,
        .core.number = PbPFtpFactoryResetParams_FieldNumber_Sleep,
        .core.hasIndex = 0,
        .core.offset = 1,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = YES,
        .core.name = "doFactoryDefaults",
        .core.dataTypeSpecific.className = NULL,
        .core.number = PbPFtpFactoryResetParams_FieldNumber_DoFactoryDefaults,
        .core.hasIndex = 2,
        .core.offset = 3,  // Stored in _has_storage_ to save space.
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "otaFwupdate",
        .core.dataTypeSpecific.className = NULL,
        .core.number = PbPFtpFactoryResetParams_FieldNumber_OtaFwupdate,
        .core.hasIndex = 4,
        .core.offset = 5,  // Stored in _has_storage_ to save space.
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbPFtpFactoryResetParams class]
                                     rootClass:[PftpNotificationRoot class]
                                          file:PftpNotificationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(PbPFtpFactoryResetParams__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbPFtpStartAutosyncParams

@implementation PbPFtpStartAutosyncParams

@dynamic hasTimeout, timeout;

typedef struct PbPFtpStartAutosyncParams__storage_ {
  uint32_t _has_storage_[1];
  uint32_t timeout;
} PbPFtpStartAutosyncParams__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timeout",
        .dataTypeSpecific.className = NULL,
        .number = PbPFtpStartAutosyncParams_FieldNumber_Timeout,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbPFtpStartAutosyncParams__storage_, timeout),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbPFtpStartAutosyncParams class]
                                     rootClass:[PftpNotificationRoot class]
                                          file:PftpNotificationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbPFtpStartAutosyncParams__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbPftpPnsHDAttribute

@implementation PbPftpPnsHDAttribute

@dynamic hasType, type;
@dynamic hasData_p, data_p;
@dynamic hasAttributeFullSize, attributeFullSize;

typedef struct PbPftpPnsHDAttribute__storage_ {
  uint32_t _has_storage_[1];
  PbPftpPnsHDAttributeType type;
  uint32_t attributeFullSize;
  NSString *data_p;
} PbPftpPnsHDAttribute__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = PbPftpPnsHDAttributeType_EnumDescriptor,
        .number = PbPftpPnsHDAttribute_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbPftpPnsHDAttribute__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = PbPftpPnsHDAttribute_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbPftpPnsHDAttribute__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "attributeFullSize",
        .dataTypeSpecific.className = NULL,
        .number = PbPftpPnsHDAttribute_FieldNumber_AttributeFullSize,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PbPftpPnsHDAttribute__storage_, attributeFullSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbPftpPnsHDAttribute class]
                                     rootClass:[PftpNotificationRoot class]
                                          file:PftpNotificationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbPftpPnsHDAttribute__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbPftpPnsHDNotification

@implementation PbPftpPnsHDNotification

@dynamic hasNotificationId, notificationId;
@dynamic hasCategoryId, categoryId;
@dynamic hasAction, action;
@dynamic hasIssueTime, issueTime;
@dynamic hasNewSameCategoryNotifications, newSameCategoryNotifications;
@dynamic hasUnreadSameCategoryNotifications, unreadSameCategoryNotifications;
@dynamic attributesArray, attributesArray_Count;

typedef struct PbPftpPnsHDNotification__storage_ {
  uint32_t _has_storage_[1];
  uint32_t notificationId;
  PbPftpPnsHDCategoryID categoryId;
  Action action;
  uint32_t newSameCategoryNotifications;
  uint32_t unreadSameCategoryNotifications;
  PbLocalDateTime *issueTime;
  NSMutableArray *attributesArray;
} PbPftpPnsHDNotification__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "notificationId",
        .dataTypeSpecific.className = NULL,
        .number = PbPftpPnsHDNotification_FieldNumber_NotificationId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbPftpPnsHDNotification__storage_, notificationId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "categoryId",
        .dataTypeSpecific.enumDescFunc = PbPftpPnsHDCategoryID_EnumDescriptor,
        .number = PbPftpPnsHDNotification_FieldNumber_CategoryId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbPftpPnsHDNotification__storage_, categoryId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "action",
        .dataTypeSpecific.enumDescFunc = Action_EnumDescriptor,
        .number = PbPftpPnsHDNotification_FieldNumber_Action,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PbPftpPnsHDNotification__storage_, action),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "issueTime",
        .dataTypeSpecific.className = GPBStringifySymbol(PbLocalDateTime),
        .number = PbPftpPnsHDNotification_FieldNumber_IssueTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PbPftpPnsHDNotification__storage_, issueTime),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "newSameCategoryNotifications",
        .dataTypeSpecific.className = NULL,
        .number = PbPftpPnsHDNotification_FieldNumber_NewSameCategoryNotifications,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PbPftpPnsHDNotification__storage_, newSameCategoryNotifications),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "unreadSameCategoryNotifications",
        .dataTypeSpecific.className = NULL,
        .number = PbPftpPnsHDNotification_FieldNumber_UnreadSameCategoryNotifications,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PbPftpPnsHDNotification__storage_, unreadSameCategoryNotifications),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "attributesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PbPftpPnsHDAttribute),
        .number = PbPftpPnsHDNotification_FieldNumber_AttributesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PbPftpPnsHDNotification__storage_, attributesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbPftpPnsHDNotification class]
                                     rootClass:[PftpNotificationRoot class]
                                          file:PftpNotificationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbPftpPnsHDNotification__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbPFtpGPSDataParams

@implementation PbPFtpGPSDataParams

@dynamic hasLatitude, latitude;
@dynamic hasLongitude, longitude;
@dynamic hasSpeed, speed;
@dynamic hasDistance, distance;
@dynamic hasAltitude, altitude;
@dynamic hasSatelliteAmount, satelliteAmount;
@dynamic hasTimeOffset, timeOffset;

typedef struct PbPFtpGPSDataParams__storage_ {
  uint32_t _has_storage_[1];
  float speed;
  float distance;
  float altitude;
  uint32_t satelliteAmount;
  uint32_t timeOffset;
  double latitude;
  double longitude;
} PbPFtpGPSDataParams__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "latitude",
        .dataTypeSpecific.className = NULL,
        .number = PbPFtpGPSDataParams_FieldNumber_Latitude,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbPFtpGPSDataParams__storage_, latitude),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "longitude",
        .dataTypeSpecific.className = NULL,
        .number = PbPFtpGPSDataParams_FieldNumber_Longitude,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbPFtpGPSDataParams__storage_, longitude),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "speed",
        .dataTypeSpecific.className = NULL,
        .number = PbPFtpGPSDataParams_FieldNumber_Speed,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PbPFtpGPSDataParams__storage_, speed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "distance",
        .dataTypeSpecific.className = NULL,
        .number = PbPFtpGPSDataParams_FieldNumber_Distance,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PbPFtpGPSDataParams__storage_, distance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "altitude",
        .dataTypeSpecific.className = NULL,
        .number = PbPFtpGPSDataParams_FieldNumber_Altitude,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PbPFtpGPSDataParams__storage_, altitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "satelliteAmount",
        .dataTypeSpecific.className = NULL,
        .number = PbPFtpGPSDataParams_FieldNumber_SatelliteAmount,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PbPFtpGPSDataParams__storage_, satelliteAmount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "timeOffset",
        .dataTypeSpecific.className = NULL,
        .number = PbPFtpGPSDataParams_FieldNumber_TimeOffset,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PbPFtpGPSDataParams__storage_, timeOffset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbPFtpGPSDataParams class]
                                     rootClass:[PftpNotificationRoot class]
                                          file:PftpNotificationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbPFtpGPSDataParams__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
