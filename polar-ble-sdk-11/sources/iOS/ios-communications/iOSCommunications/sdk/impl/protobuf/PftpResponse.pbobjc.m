// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pftp_response.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "PftpResponse.pbobjc.h"
 #import "Types.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - PftpResponseRoot

@implementation PftpResponseRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    registry = [[GPBExtensionRegistry alloc] init];
    // Merge in the imports (direct or indirect) that defined extensions.
    [registry addExtensions:[TypesRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - PftpResponseRoot_FileDescriptor

static GPBFileDescriptor *PftpResponseRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"protocol"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - PbPFtpEntry

@implementation PbPFtpEntry

@dynamic hasName, name;
@dynamic hasSize, size;
@dynamic hasCreated, created;
@dynamic hasModified, modified;
@dynamic hasTouched, touched;

typedef struct PbPFtpEntry__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  PbSystemDateTime *created;
  PbSystemDateTime *modified;
  PbSystemDateTime *touched;
  uint64_t size;
} PbPFtpEntry__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = PbPFtpEntry_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbPFtpEntry__storage_, name),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "size",
        .dataTypeSpecific.className = NULL,
        .number = PbPFtpEntry_FieldNumber_Size,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbPFtpEntry__storage_, size),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "created",
        .dataTypeSpecific.className = GPBStringifySymbol(PbSystemDateTime),
        .number = PbPFtpEntry_FieldNumber_Created,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PbPFtpEntry__storage_, created),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "modified",
        .dataTypeSpecific.className = GPBStringifySymbol(PbSystemDateTime),
        .number = PbPFtpEntry_FieldNumber_Modified,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PbPFtpEntry__storage_, modified),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "touched",
        .dataTypeSpecific.className = GPBStringifySymbol(PbSystemDateTime),
        .number = PbPFtpEntry_FieldNumber_Touched,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PbPFtpEntry__storage_, touched),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbPFtpEntry class]
                                     rootClass:[PftpResponseRoot class]
                                          file:PftpResponseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbPFtpEntry__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbPFtpDirectory

@implementation PbPFtpDirectory

@dynamic entriesArray, entriesArray_Count;

typedef struct PbPFtpDirectory__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *entriesArray;
} PbPFtpDirectory__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "entriesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PbPFtpEntry),
        .number = PbPFtpDirectory_FieldNumber_EntriesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PbPFtpDirectory__storage_, entriesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbPFtpDirectory class]
                                     rootClass:[PftpResponseRoot class]
                                          file:PftpResponseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbPFtpDirectory__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbPFtpIdentifyDeviceResult

@implementation PbPFtpIdentifyDeviceResult

@dynamic hasDeviceId, deviceId;

typedef struct PbPFtpIdentifyDeviceResult__storage_ {
  uint32_t _has_storage_[1];
  NSString *deviceId;
} PbPFtpIdentifyDeviceResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deviceId",
        .dataTypeSpecific.className = NULL,
        .number = PbPFtpIdentifyDeviceResult_FieldNumber_DeviceId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbPFtpIdentifyDeviceResult__storage_, deviceId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbPFtpIdentifyDeviceResult class]
                                     rootClass:[PftpResponseRoot class]
                                          file:PftpResponseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbPFtpIdentifyDeviceResult__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbPFtpGetSystemTimeResult

@implementation PbPFtpGetSystemTimeResult

@dynamic hasDate, date;
@dynamic hasTime, time;
@dynamic hasTrusted, trusted;

typedef struct PbPFtpGetSystemTimeResult__storage_ {
  uint32_t _has_storage_[1];
  PbDate *date;
  PbTime *time;
} PbPFtpGetSystemTimeResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "date",
        .dataTypeSpecific.className = GPBStringifySymbol(PbDate),
        .number = PbPFtpGetSystemTimeResult_FieldNumber_Date,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbPFtpGetSystemTimeResult__storage_, date),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "time",
        .dataTypeSpecific.className = GPBStringifySymbol(PbTime),
        .number = PbPFtpGetSystemTimeResult_FieldNumber_Time,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbPFtpGetSystemTimeResult__storage_, time),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "trusted",
        .dataTypeSpecific.className = NULL,
        .number = PbPFtpGetSystemTimeResult_FieldNumber_Trusted,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbPFtpGetSystemTimeResult class]
                                     rootClass:[PftpResponseRoot class]
                                          file:PftpResponseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbPFtpGetSystemTimeResult__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbPFtpGetLocalTimeResult

@implementation PbPFtpGetLocalTimeResult

@dynamic hasDate, date;
@dynamic hasTime, time;
@dynamic hasTzOffset, tzOffset;

typedef struct PbPFtpGetLocalTimeResult__storage_ {
  uint32_t _has_storage_[1];
  int32_t tzOffset;
  PbDate *date;
  PbTime *time;
} PbPFtpGetLocalTimeResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "date",
        .dataTypeSpecific.className = GPBStringifySymbol(PbDate),
        .number = PbPFtpGetLocalTimeResult_FieldNumber_Date,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbPFtpGetLocalTimeResult__storage_, date),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "time",
        .dataTypeSpecific.className = GPBStringifySymbol(PbTime),
        .number = PbPFtpGetLocalTimeResult_FieldNumber_Time,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbPFtpGetLocalTimeResult__storage_, time),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tzOffset",
        .dataTypeSpecific.className = NULL,
        .number = PbPFtpGetLocalTimeResult_FieldNumber_TzOffset,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PbPFtpGetLocalTimeResult__storage_, tzOffset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbPFtpGetLocalTimeResult class]
                                     rootClass:[PftpResponseRoot class]
                                          file:PftpResponseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbPFtpGetLocalTimeResult__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbPFtpDiskSpaceResult

@implementation PbPFtpDiskSpaceResult

@dynamic hasFragmentSize, fragmentSize;
@dynamic hasTotalFragments, totalFragments;
@dynamic hasFreeFragments, freeFragments;

typedef struct PbPFtpDiskSpaceResult__storage_ {
  uint32_t _has_storage_[1];
  uint32_t fragmentSize;
  uint64_t totalFragments;
  uint64_t freeFragments;
} PbPFtpDiskSpaceResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fragmentSize",
        .dataTypeSpecific.className = NULL,
        .number = PbPFtpDiskSpaceResult_FieldNumber_FragmentSize,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbPFtpDiskSpaceResult__storage_, fragmentSize),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "totalFragments",
        .dataTypeSpecific.className = NULL,
        .number = PbPFtpDiskSpaceResult_FieldNumber_TotalFragments,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PbPFtpDiskSpaceResult__storage_, totalFragments),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "freeFragments",
        .dataTypeSpecific.className = NULL,
        .number = PbPFtpDiskSpaceResult_FieldNumber_FreeFragments,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PbPFtpDiskSpaceResult__storage_, freeFragments),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbPFtpDiskSpaceResult class]
                                     rootClass:[PftpResponseRoot class]
                                          file:PftpResponseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbPFtpDiskSpaceResult__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbPFtpGenerateChallengeTokenResult

@implementation PbPFtpGenerateChallengeTokenResult

@dynamic hasToken, token;

typedef struct PbPFtpGenerateChallengeTokenResult__storage_ {
  uint32_t _has_storage_[1];
  NSData *token;
} PbPFtpGenerateChallengeTokenResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = PbPFtpGenerateChallengeTokenResult_FieldNumber_Token,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbPFtpGenerateChallengeTokenResult__storage_, token),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbPFtpGenerateChallengeTokenResult class]
                                     rootClass:[PftpResponseRoot class]
                                          file:PftpResponseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbPFtpGenerateChallengeTokenResult__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbPFtpBatteryStatusResult

@implementation PbPFtpBatteryStatusResult

@dynamic hasBatteryStatus, batteryStatus;
@dynamic hasCharging, charging;

typedef struct PbPFtpBatteryStatusResult__storage_ {
  uint32_t _has_storage_[1];
  uint32_t batteryStatus;
} PbPFtpBatteryStatusResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "batteryStatus",
        .dataTypeSpecific.className = NULL,
        .number = PbPFtpBatteryStatusResult_FieldNumber_BatteryStatus,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PbPFtpBatteryStatusResult__storage_, batteryStatus),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "charging",
        .dataTypeSpecific.className = NULL,
        .number = PbPFtpBatteryStatusResult_FieldNumber_Charging,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbPFtpBatteryStatusResult class]
                                     rootClass:[PftpResponseRoot class]
                                          file:PftpResponseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbPFtpBatteryStatusResult__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbPFtpGetInactivityPreAlertResult

@implementation PbPFtpGetInactivityPreAlertResult

@dynamic hasInactivityPreAlertOn, inactivityPreAlertOn;

typedef struct PbPFtpGetInactivityPreAlertResult__storage_ {
  uint32_t _has_storage_[1];
} PbPFtpGetInactivityPreAlertResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "inactivityPreAlertOn",
        .dataTypeSpecific.className = NULL,
        .number = PbPFtpGetInactivityPreAlertResult_FieldNumber_InactivityPreAlertOn,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbPFtpGetInactivityPreAlertResult class]
                                     rootClass:[PftpResponseRoot class]
                                          file:PftpResponseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbPFtpGetInactivityPreAlertResult__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PbRequestRecordingStatusResult

@implementation PbRequestRecordingStatusResult

@dynamic hasRecordingOn, recordingOn;
@dynamic hasSampleDataIdentifier, sampleDataIdentifier;

typedef struct PbRequestRecordingStatusResult__storage_ {
  uint32_t _has_storage_[1];
  NSString *sampleDataIdentifier;
} PbRequestRecordingStatusResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "recordingOn",
        .dataTypeSpecific.className = NULL,
        .number = PbRequestRecordingStatusResult_FieldNumber_RecordingOn,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "sampleDataIdentifier",
        .dataTypeSpecific.className = NULL,
        .number = PbRequestRecordingStatusResult_FieldNumber_SampleDataIdentifier,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PbRequestRecordingStatusResult__storage_, sampleDataIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PbRequestRecordingStatusResult class]
                                     rootClass:[PftpResponseRoot class]
                                          file:PftpResponseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PbRequestRecordingStatusResult__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
